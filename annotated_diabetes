--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         23068672 B, 64 B, 11-way associative
Command:          ./genetic_benchmark diabetes
Data file:        cachegrind.out.5473
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr           Dr                     D1mr             DLmr           Dw                   D1mw             DLmw             
--------------------------------------------------------------------------------
5,475,214,715 (100.0%) 5,725 (100.0%) 3,586 (100.0%) 1,255,118,271 (100.0%) 890,466 (100.0%) 9,006 (100.0%) 411,400,438 (100.0%) 896,694 (100.0%) 101,529 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                   D1mr             DLmr           Dw                   D1mw             DLmw             file:function
--------------------------------------------------------------------------------
1,293,970,458 (23.63%)   2 ( 0.03%)   2 ( 0.06%) 475,209,692 (37.86%)  55,203 ( 6.20%)     0          231,358,380 (56.24%)      11 ( 0.00%)      0           /home/dhruvs6/598APE-HW2/src/node_detail.h:void genetic::execute_kernel<20>(genetic::program*, float const*, float*, unsigned long, unsigned long) [clone ._omp_fn.0]
1,237,920,976 (22.61%)   8 ( 0.14%)   2 ( 0.06%) 112,192,694 ( 8.94%)       0              0          126,693,414 (30.80%)      61 ( 0.01%)      3 ( 0.00%)  /home/dhruvs6/598APE-HW2/src/reg_stack.h:void genetic::execute_kernel<20>(genetic::program*, float const*, float*, unsigned long, unsigned long) [clone ._omp_fn.0]
  962,783,088 (17.58%)  21 ( 0.37%)   6 ( 0.17%) 121,009,066 ( 9.64%)  30,663 ( 3.44%)     0            2,942,266 ( 0.72%) 181,498 (20.24%)     12 ( 0.01%)  /home/dhruvs6/598APE-HW2/src/program.cpp:void genetic::execute_kernel<20>(genetic::program*, float const*, float*, unsigned long, unsigned long) [clone ._omp_fn.0]
  548,845,407 (10.02%)  10 ( 0.17%)   5 ( 0.14%) 156,267,292 (12.45%)     370 ( 0.04%)     8 ( 0.09%)           0                0               0           ./math/../sysdeps/ieee754/flt-32/e_expf.c:__expf_fma
  224,385,388 ( 4.10%)   1 ( 0.02%)   1 ( 0.03%) 112,192,694 ( 8.94%)      18 ( 0.00%)     0                    0                0               0           /usr/include/c++/11/bits/unique_ptr.h:void genetic::execute_kernel<20>(genetic::program*, float const*, float*, unsigned long, unsigned long) [clone ._omp_fn.0]
  197,355,084 ( 3.60%) 994 (17.36%) 514 (14.33%)  61,038,533 ( 4.86%)   1,737 ( 0.20%)    12 ( 0.13%)      22,777 ( 0.01%)     762 ( 0.08%)     49 ( 0.05%)  ???:???
  123,163,545 ( 2.25%)   6 ( 0.10%)   5 ( 0.14%)  28,934,015 ( 2.31%)     362 ( 0.04%)     5 ( 0.06%)           0                0               0           ./math/../sysdeps/ieee754/flt-32/e_logf.c:__logf_fma
   86,939,927 ( 1.59%)   5 ( 0.09%)   2 ( 0.06%)  18,795,754 ( 1.50%)      18 ( 0.00%)     1 ( 0.01%)           0                0               0           ./math/./s_fdim_template.c:fdimf
   86,874,315 ( 1.59%)  17 ( 0.30%)   4 ( 0.11%)   9,015,592 ( 0.72%)      76 ( 0.01%)     1 ( 0.01%)           0                0               0           ./math/../sysdeps/ieee754/flt-32/s_cosf.c:__cosf_fma
   74,163,140 ( 1.35%)   3 ( 0.05%)   3 ( 0.08%)  38,110,130 ( 3.04%)     220 ( 0.02%)     1 ( 0.01%)           0                0               0           ./math/../sysdeps/x86/fpu/sincosf_poly.h:__cosf_fma
   49,486,752 ( 0.90%)  66 ( 1.15%)   7 ( 0.20%)  11,605,680 ( 0.92%) 363,264 (40.79%)     0            2,908,320 ( 0.71%) 181,780 (20.27%)      0           /home/dhruvs6/598APE-HW2/include/fitness.h:void genetic::meanSquareError<float>(unsigned long, unsigned long, float const*, float const*, float const*, float*)
   49,409,116 ( 0.90%)  19 ( 0.33%)   3 ( 0.08%)   4,104,737 ( 0.33%)       0              0                    0                0               0           ./math/../sysdeps/ieee754/flt-32/s_sinf.c:__sinf_fma
   39,185,176 ( 0.72%)   0            0                    0                0              0                    0                0               0           ./math/../sysdeps/ieee754/flt-32/math_config.h:__expf_fma
   38,735,431 ( 0.71%)   3 ( 0.05%)   2 ( 0.06%)  17,269,337 ( 1.38%)     154 ( 0.02%)     3 ( 0.03%)           0                0               0           ./math/../sysdeps/x86/fpu/sincosf_poly.h:__sinf_fma
   35,670,966 ( 0.65%)   6 ( 0.10%)   1 ( 0.03%)  11,890,322 ( 0.95%)       0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#1}::_FUN(float, float)
   33,002,525 ( 0.60%)  16 ( 0.28%)   3 ( 0.08%)   4,415,062 ( 0.35%)     239 ( 0.03%)     0                    0                0               0           ./math/../sysdeps/ieee754/flt-32/s_sincosf.h:__cosf_fma
   26,280,250 ( 0.48%)   5 ( 0.09%)   4 ( 0.11%)   1,261,452 ( 0.10%)      16 ( 0.00%)     0            1,261,452 ( 0.31%)      14 ( 0.00%)      0           /home/dhruvs6/598APE-HW2/src/philox_rng.cpp:philox_next4
   24,158,343 ( 0.44%)  15 ( 0.26%)   4 ( 0.11%)   2,572,944 ( 0.20%)      82 ( 0.01%)     3 ( 0.03%)           0                0               0           ./math/../sysdeps/ieee754/flt-32/s_sincosf.h:__sinf_fma
   23,287,055 ( 0.43%)   8 ( 0.14%)   5 ( 0.14%)         324 ( 0.00%)      48 ( 0.01%)     0           23,282,502 ( 5.66%) 364,772 (40.68%) 94,896 (93.47%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
   22,630,938 ( 0.41%)   0            0            7,543,646 ( 0.60%)       0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#7}::_FUN(float, float)
   20,447,820 ( 0.37%)   1 ( 0.02%)   1 ( 0.03%)   6,815,940 ( 0.54%) 201,840 (22.67%)   465 ( 5.16%)   4,543,960 ( 1.10%) 109,838 (12.25%)    800 ( 0.79%)  /home/dhruvs6/598APE-HW2/src/node.cpp:genetic::node::operator=(genetic::node const&)
   19,679,996 ( 0.36%)   1 ( 0.02%)   1 ( 0.03%)           0                0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#21}::_FUN(float, float)
   19,679,996 ( 0.36%)   0            0                    0                0              0                    0                0               0           /usr/include/c++/11/cmath:function_table::{lambda(float, float)#21}::_FUN(float, float)
   19,187,712 ( 0.35%)   1 ( 0.02%)   1 ( 0.03%)   5,183,020 ( 0.41%)       0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#23}::_FUN(float, float)
   14,326,720 ( 0.26%)   2 ( 0.03%)   1 ( 0.03%)   7,163,360 ( 0.57%)       0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#10}::_FUN(float, float)
   12,859,467 ( 0.23%)  19 ( 0.33%)   6 ( 0.17%)   2,128,361 ( 0.17%)       0              0            2,387,847 ( 0.58%)       0               0           /home/dhruvs6/598APE-HW2/src/program.cpp:genetic::get_subtree(genetic::node*, int, PhiloxEngine&)
   12,814,614 ( 0.23%)   1 ( 0.02%)   1 ( 0.03%)   4,271,538 ( 0.34%)       0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#9}::_FUN(float, float)
   11,862,648 ( 0.22%)   4 ( 0.07%)   4 ( 0.11%)   4,448,493 ( 0.35%)       0              0            3,459,939 ( 0.84%)       0               0           /usr/include/c++/11/bits/deque.tcc:int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]
   11,184,057 ( 0.20%)  33 ( 0.58%)   8 ( 0.22%)   3,304,451 ( 0.26%)       0              0            1,685,578 ( 0.41%)       0               0           /usr/include/c++/11/bits/stl_deque.h:genetic::get_depth(genetic::program const&)
   10,882,345 ( 0.20%)   0            0                    0                0              0                    0                0               0           ./math/../sysdeps/ieee754/flt-32/math_config.h:__cosf_fma
    8,667,328 ( 0.16%)   1 ( 0.02%)   1 ( 0.03%)           0                0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#18}::_FUN(float, float)
    8,667,328 ( 0.16%)   0            0                    0                0              0                    0                0               0           /usr/include/c++/11/cmath:function_table::{lambda(float, float)#18}::_FUN(float, float)
    8,467,584 ( 0.15%)   0            0                    0                0              0                    0                0               0           /home/dhruvs6/598APE-HW2/src/../include/evaluate.h:function_table::{lambda(float, float)#4}::_FUN(float, float)
    8,467,584 ( 0.15%)   0            0                    0                0              0                    0                0               0           /usr/include/c++/11/cmath:function_table::{lambda(float, float)#4}::_FUN(float, float)
    7,163,360 ( 0.13%)   0            0            7,163,360 ( 0.57%)      13 ( 0.00%)     0                    0                0               0           /usr/include/c++/11/bits/std_abs.h:function_table::{lambda(float, float)#10}::_FUN(float, float)
    6,321,471 ( 0.12%)   0            0                    0                0              0                    0                0               0           ./math/../sysdeps/ieee754/flt-32/math_config.h:__sinf_fma
    5,899,845 ( 0.11%)  16 ( 0.28%)   3 ( 0.08%)   1,495,467 ( 0.12%)       0              0            1,304,465 ( 0.32%)       0               0           /home/dhruvs6/598APE-HW2/src/program.cpp:genetic::get_depth(genetic::program const&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dhruvs6/598APE-HW2/src/reg_stack.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                   D1mr       DLmr       Dw                   D1mw        DLmw       

-- line 7 ----------------------------------------
          .          .          .                    .          .          .                    .           .          .                *
          .          .          .                    .          .          .                    .           .          .                * The idea is to use only the registers to store the elements of the stack,
          .          .          .                    .          .          .                    .           .          .                * thereby achieving the best performance.
          .          .          .                    .          .          .                    .           .          .                *
          .          .          .                    .          .          .                    .           .          .                * @tparam DataT   data type of the stack elements
          .          .          .                    .          .          .                    .           .          .                * @tparam MaxSize max capacity of the stack
          .          .          .                    .          .          .                    .           .          .                */
          .          .          .                    .          .          .                    .           .          .               template <typename DataT, int MaxSize> struct stack {
  8,700,432 ( 0.16%) 0          0                    0          0          0                    0           0          0                   explicit stack() : elements_(0) {
          .          .          .                    .          .          .                    .           .          .                       // could replace with memset
          .          .          .                    .          .          .                    .           .          .                       for (int i = 0; i < MaxSize; ++i) {
 17,400,864 ( 0.32%) 1 ( 0.02%) 1 ( 0.03%)           0          0          0           14,500,720 ( 3.52%) 43 ( 0.00%) 3 ( 0.00%)                  regs_[i] = DataT(0);
          .          .          .                    .          .          .                    .           .          .                       }
          .          .          .                    .          .          .                    .           .          .                   }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .                   /** Checks if the stack is empty */
          .          .          .                    .          .          .                    .           .          .                   inline bool empty() const { return elements_ == 0; }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .                   /** Current number of elements in the stack */
          .          .          .                    .          .          .                    .           .          .                   inline int size() const { return elements_; }
-- line 26 ----------------------------------------
-- line 40 ----------------------------------------
          .          .          .                    .          .          .                    .           .          .                    */
          .          .          .                    .          .          .                    .           .          .                   void push(DataT val) {
          .          .          .                    .          .          .                    .           .          .                       // for (int i = MaxSize - 1; i >= 0; --i) {
          .          .          .                    .          .          .                    .           .          .                       //   if (elements_ == i) {
          .          .          .                    .          .          .                    .           .          .                       //     ++elements_;
          .          .          .                    .          .          .                    .           .          .                       //     regs_[i] = val;
          .          .          .                    .          .          .                    .           .          .                       //   }
          .          .          .                    .          .          .                    .           .          .                       // }
224,385,388 ( 4.10%) 0          0                    0          0          0                    0           0          0                       if (!full()) {
224,385,388 ( 4.10%) 0          0                    0          0          0          112,192,694 (27.27%) 18 ( 0.00%) 0                           regs_[elements_] = val;
112,192,694 ( 2.05%) 0          0                    0          0          0                    0           0          0                           elements_++;
          .          .          .                    .          .          .                    .           .          .                       }
          .          .          .                    .          .          .                    .           .          .                   }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .                   /**
          .          .          .                    .          .          .                    .           .          .                    * @brief Lazily pops the top element from the stack
          .          .          .                    .          .          .                    .           .          .                    *
          .          .          .                    .          .          .                    .           .          .                    * @return pops the element and returns it, if already reached bottom, then it
          .          .          .                    .          .          .                    .           .          .                    *         returns zero.
-- line 58 ----------------------------------------
-- line 65 ----------------------------------------
          .          .          .                    .          .          .                    .           .          .                   DataT pop() {
          .          .          .                    .          .          .                    .           .          .                       // for (int i = 0; i < MaxSize; ++i) {
          .          .          .                    .          .          .                    .           .          .                       //   if (elements_ == (i + 1)) {
          .          .          .                    .          .          .                    .           .          .                       //     elements_--;
          .          .          .                    .          .          .                    .           .          .                       //     return regs_[i];
          .          .          .                    .          .          .                    .           .          .                       //   }
          .          .          .                    .          .          .                    .           .          .                       // }
          .          .          .                    .          .          .                    .           .          .           
650,856,210 (11.89%) 7 ( 0.12%) 1 ( 0.03%) 112,192,694 ( 8.94%) 0          0                    0           0          0                       return empty() ? DataT(0) : regs_[(--elements_)];
          .          .          .                    .          .          .                    .           .          .                   }
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .               private:
          .          .          .                    .          .          .                    .           .          .                   int   elements_;
          .          .          .                    .          .          .                    .           .          .                   DataT regs_[MaxSize];
          .          .          .                    .          .          .                    .           .          .               }; // struct stack
          .          .          .                    .          .          .                    .           .          .           
          .          .          .                    .          .          .                    .           .          .           } // namespace genetic
-- line 81 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dhruvs6/598APE-HW2/include/fitness.h
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr       Dr                 D1mr             DLmr       Dw                 D1mw             DLmw       

-- line 217 ----------------------------------------
         .           .          .                  .                .          .                  .                .          .                       out[pid] = static_cast<math_t>(0);
         .           .          .                  .                .          .                  .                .          .                       for (uint64_t i = 0; i < n_samples; ++i) {
         .           .          .                  .                .          .                  .                .          .                           out[pid] += error[pid * n_samples + i] / N;
         .           .          .                  .                .          .                  .                .          .                       }
         .           .          .                  .                .          .                  .                .          .                   }
         .           .          .                  .                .          .                  .                .          .               }
         .           .          .                  .                .          .                  .                .          .           
         .           .          .                  .                .          .                  .                .          .               template <typename math_t = float>
       144 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)         0                0          0                 96 ( 0.00%)       0          0               void meanSquareError(const uint64_t n_samples, const uint64_t n_progs, const math_t* Y,
         .           .          .                  .                .          .                  .                .          .                                    const math_t* Y_pred, const math_t* W, math_t* out) {
        32 ( 0.00%) 16 ( 0.28%) 1 ( 0.03%)         0                0          0                  0                0          0                   std::vector<math_t> error(n_samples * n_progs);
        64 ( 0.00%)  0          0                  0                0          0                  0                0          0                   math_t              N = static_cast<math_t>(n_samples);
         .           .          .                  .                .          .                  .                .          .           
         .           .          .                  .                .          .                  .                .          .                   // Weight Sum
        80 ( 0.00%)  0          0                  0                0          0                  0                0          0                   math_t WS = static_cast<math_t>(0);
    17,024 ( 0.00%)  0          0                  0                0          0                  0                0          0                   for (uint64_t i = 0; i < n_samples; ++i) {
     5,664 ( 0.00%) 16 ( 0.28%) 1 ( 0.03%)     5,664 ( 0.00%)     368 ( 0.04%) 0                  0                0          0                       WS += W[i];
         .           .          .                  .                .          .                  .                .          .                   }
         .           .          .                  .                .          .                  .                .          .           
         .           .          .                  .                .          .                  .                .          .                   // Compute absolute differences
    41,056 ( 0.00%)  0          0                  0                0          0                  0                0          0                   for (uint64_t pid = 0; pid < n_progs; ++pid) {
 8,732,688 ( 0.16%)  0          0                  0                0          0                  0                0          0                       for (uint64_t i = 0; i < n_samples; ++i) {
20,299,776 ( 0.37%) 16 ( 0.28%) 1 ( 0.03%) 8,699,904 ( 0.69%) 181,627 (20.40%) 0          2,899,968 ( 0.70%) 181,261 (20.21%) 0                           error[pid * n_samples + i] = N * W[i] * (Y_pred[pid * n_samples + i] - Y[i]) *
 2,899,968 ( 0.05%)  0          0                  0                0          0                  0                0          0                                                        (Y_pred[pid * n_samples + i] - Y[i]) / WS;
         .           .          .                  .                .          .                  .                .          .                       }
         .           .          .                  .                .          .                  .                .          .                   }
         .           .          .                  .                .          .                  .                .          .           
         .           .          .                  .                .          .                  .                .          .                   // Average along rows
    32,768 ( 0.00%)  0          0                  0                0          0                  0                0          0                   for (uint64_t pid = 0; pid < n_progs; ++pid) {
       224 ( 0.00%)  6 ( 0.10%) 1 ( 0.03%)        48 ( 0.00%)       0          0                 64 ( 0.00%)      32 ( 0.00%) 0                       out[pid] = static_cast<math_t>(0);
 8,757,248 ( 0.16%)  6 ( 0.10%) 1 ( 0.03%)         0                0          0              8,192 ( 0.00%)     487 ( 0.05%) 0                       for (uint64_t i = 0; i < n_samples; ++i) {
 8,699,904 ( 0.16%)  0          0          2,899,968 ( 0.23%) 181,253 (20.35%) 0                  0                0          0                           out[pid] += error[pid * n_samples + i] / N;
         .           .          .                  .                .          .                  .                .          .                       }
         .           .          .                  .                .          .                  .                .          .                   }
       112 ( 0.00%)  5 ( 0.09%) 1 ( 0.03%)        96 ( 0.00%)      16 ( 0.00%) 0                  0                0          0               }
         .           .          .                  .                .          .                  .                .          .           
         .           .          .                  .                .          .                  .                .          .               template <typename math_t = float>
         .           .          .                  .                .          .                  .                .          .               void rootMeanSquareError(const uint64_t n_samples, const uint64_t n_progs, const math_t* Y,
         .           .          .                  .                .          .                  .                .          .                                        const math_t* Y_pred, const math_t* W, math_t* out) {
         .           .          .                  .                .          .                  .                .          .                   // Find MSE
         .           .          .                  .                .          .                  .                .          .                   meanSquareError(n_samples, n_progs, Y, Y_pred, W, out);
         .           .          .                  .                .          .                  .                .          .           
         .           .          .                  .                .          .                  .                .          .                   // Take sqrt on all entries
-- line 259 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/deque.tcc
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr       DLmr       Dw                 D1mw       DLmw       

-- line 156 ----------------------------------------
        .          .          .                  .          .          .                  .          .          .           
        .          .          .                  .          .          .                  .          .          .             template<typename _Tp, typename _Alloc>
        .          .          .                  .          .          .                  .          .          .               template<typename... _Args>
        .          .          .                  .          .          .                  .          .          .           #if __cplusplus > 201402L
        .          .          .                  .          .          .                  .          .          .                 typename deque<_Tp, _Alloc>::reference
        .          .          .                  .          .          .                  .          .          .           #else
        .          .          .                  .          .          .                  .          .          .                 void
        .          .          .                  .          .          .                  .          .          .           #endif
4,448,493 ( 0.08%) 2 ( 0.03%) 2 ( 0.06%)         0          0          0          2,965,662 ( 0.72%) 0          0                 deque<_Tp, _Alloc>::
        .          .          .                  .          .          .                  .          .          .                 emplace_back(_Args&&... __args)
        .          .          .                  .          .          .                  .          .          .                 {
1,482,831 ( 0.03%) 1 ( 0.02%) 1 ( 0.03%)   494,277 ( 0.04%) 0          0                  0          0          0           	if (this->_M_impl._M_finish._M_cur
  988,554 ( 0.02%) 0          0            494,277 ( 0.04%) 0          0                  0          0          0           	    != this->_M_impl._M_finish._M_last - 1)
        .          .          .                  .          .          .                  .          .          .           	  {
        .          .          .                  .          .          .                  .          .          .           	    _Alloc_traits::construct(this->_M_impl,
        .          .          .                  .          .          .                  .          .          .           				     this->_M_impl._M_finish._M_cur,
        .          .          .                  .          .          .                  .          .          .           				     std::forward<_Args>(__args)...);
  988,554 ( 0.02%) 0          0                  0          0          0            494,277 ( 0.12%) 0          0           	    ++this->_M_impl._M_finish._M_cur;
        .          .          .                  .          .          .                  .          .          .           	  }
        .          .          .                  .          .          .                  .          .          .           	else
        .          .          .                  .          .          .                  .          .          .           	  _M_push_back_aux(std::forward<_Args>(__args)...);
        .          .          .                  .          .          .                  .          .          .           #if __cplusplus > 201402L
        .          .          .                  .          .          .                  .          .          .           	return back();
        .          .          .                  .          .          .                  .          .          .           #endif
3,954,216 ( 0.07%) 1 ( 0.02%) 1 ( 0.03%) 3,459,939 ( 0.28%) 0          0                  0          0          0                 }
        .          .          .                  .          .          .                  .          .          .           #endif
        .          .          .                  .          .          .                  .          .          .           
        .          .          .                  .          .          .                  .          .          .           #if __cplusplus >= 201103L
        .          .          .                  .          .          .                  .          .          .             template<typename _Tp, typename _Alloc>
        .          .          .                  .          .          .                  .          .          .               template<typename... _Args>
        .          .          .                  .          .          .                  .          .          .                 typename deque<_Tp, _Alloc>::iterator
        .          .          .                  .          .          .                  .          .          .                 deque<_Tp, _Alloc>::
        .          .          .                  .          .          .                  .          .          .                 emplace(const_iterator __position, _Args&&... __args)
-- line 188 ----------------------------------------
-- line 557 ----------------------------------------
        .          .          .                  .          .          .                  .          .          .           
        .          .          .                  .          .          .                  .          .          .             // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_first.
        .          .          .                  .          .          .                  .          .          .             template <typename _Tp, typename _Alloc>
        .          .          .                  .          .          .                  .          .          .               void deque<_Tp, _Alloc>::
        .          .          .                  .          .          .                  .          .          .               _M_pop_back_aux()
        .          .          .                  .          .          .                  .          .          .               {
        .          .          .                  .          .          .                  .          .          .                 _M_deallocate_node(this->_M_impl._M_finish._M_first);
        .          .          .                  .          .          .                  .          .          .                 this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
  204,431 ( 0.00%) 0          0                  0          0          0            204,431 ( 0.05%) 0          0                 this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
        .          .          .                  .          .          .                  .          .          .                 _Alloc_traits::destroy(_M_get_Tp_allocator(),
        .          .          .                  .          .          .                  .          .          .           			     this->_M_impl._M_finish._M_cur);
        .          .          .                  .          .          .                  .          .          .               }
        .          .          .                  .          .          .                  .          .          .           
        .          .          .                  .          .          .                  .          .          .             // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.
        .          .          .                  .          .          .                  .          .          .             // Note that if the deque has at least one element (a precondition for this
        .          .          .                  .          .          .                  .          .          .             // member function), and if
        .          .          .                  .          .          .                  .          .          .             //   _M_impl._M_start._M_cur == _M_impl._M_start._M_last,
-- line 573 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/cmath
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr         D1mr       DLmr       Dw         D1mw       DLmw       

-- line 177 ----------------------------------------
         .          .          .          .          .          .          .          .          .               ceil(_Tp __x)
         .          .          .          .          .          .          .          .          .               { return __builtin_ceil(__x); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             using ::cos;
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .           #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR float
         .          .          .          .          .          .          .          .          .             cos(float __x)
 8,667,328 ( 0.16%) 0          0          0          0          0          0          0          0             { return __builtin_cosf(__x); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR long double
         .          .          .          .          .          .          .          .          .             cos(long double __x)
         .          .          .          .          .          .          .          .          .             { return __builtin_cosl(__x); }
         .          .          .          .          .          .          .          .          .           #endif
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             template<typename _Tp>
         .          .          .          .          .          .          .          .          .               inline _GLIBCXX_CONSTEXPR
-- line 193 ----------------------------------------
-- line 215 ----------------------------------------
         .          .          .          .          .          .          .          .          .               cosh(_Tp __x)
         .          .          .          .          .          .          .          .          .               { return __builtin_cosh(__x); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             using ::exp;
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .           #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR float
         .          .          .          .          .          .          .          .          .             exp(float __x)
19,679,996 ( 0.36%) 0          0          0          0          0          0          0          0             { return __builtin_expf(__x); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR long double
         .          .          .          .          .          .          .          .          .             exp(long double __x)
         .          .          .          .          .          .          .          .          .             { return __builtin_expl(__x); }
         .          .          .          .          .          .          .          .          .           #endif
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             template<typename _Tp>
         .          .          .          .          .          .          .          .          .               inline _GLIBCXX_CONSTEXPR
-- line 231 ----------------------------------------
-- line 331 ----------------------------------------
         .          .          .          .          .          .          .          .          .               ldexp(_Tp __x, int __exp)
         .          .          .          .          .          .          .          .          .               { return __builtin_ldexp(__x, __exp); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             using ::log;
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .           #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR float
         .          .          .          .          .          .          .          .          .             log(float __x)
 3,638,652 ( 0.07%) 0          0          0          0          0          0          0          0             { return __builtin_logf(__x); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR long double
         .          .          .          .          .          .          .          .          .             log(long double __x)
         .          .          .          .          .          .          .          .          .             { return __builtin_logl(__x); }
         .          .          .          .          .          .          .          .          .           #endif
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             template<typename _Tp>
         .          .          .          .          .          .          .          .          .               inline _GLIBCXX_CONSTEXPR
-- line 347 ----------------------------------------
-- line 418 ----------------------------------------
         .          .          .          .          .          .          .          .          .                 return pow(__type(__x), __type(__y));
         .          .          .          .          .          .          .          .          .               }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             using ::sin;
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .           #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR float
         .          .          .          .          .          .          .          .          .             sin(float __x)
 5,024,850 ( 0.09%) 0          0          0          0          0          0          0          0             { return __builtin_sinf(__x); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             inline _GLIBCXX_CONSTEXPR long double
         .          .          .          .          .          .          .          .          .             sin(long double __x)
         .          .          .          .          .          .          .          .          .             { return __builtin_sinl(__x); }
         .          .          .          .          .          .          .          .          .           #endif
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             template<typename _Tp>
         .          .          .          .          .          .          .          .          .               inline _GLIBCXX_CONSTEXPR
-- line 434 ----------------------------------------
-- line 1371 ----------------------------------------
         .          .          .          .          .          .          .          .          .                                                         double>::__type
         .          .          .          .          .          .          .          .          .               expm1(_Tp __x)
         .          .          .          .          .          .          .          .          .               { return __builtin_expm1(__x); }
         .          .          .          .          .          .          .          .          .           #endif
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .           #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
         .          .          .          .          .          .          .          .          .             constexpr float
         .          .          .          .          .          .          .          .          .             fdim(float __x, float __y)
 8,467,584 ( 0.15%) 0          0          0          0          0          0          0          0             { return __builtin_fdimf(__x, __y); }
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .             constexpr long double
         .          .          .          .          .          .          .          .          .             fdim(long double __x, long double __y)
         .          .          .          .          .          .          .          .          .             { return __builtin_fdiml(__x, __y); }
         .          .          .          .          .          .          .          .          .           #endif
         .          .          .          .          .          .          .          .          .           
         .          .          .          .          .          .          .          .          .           #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_INT
         .          .          .          .          .          .          .          .          .             template<typename _Tp, typename _Up>
-- line 1387 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dhruvs6/598APE-HW2/src/program.cpp
--------------------------------------------------------------------------------
Ir                   I1mr        ILmr       Dr                   D1mr            DLmr       Dw                 D1mw             DLmw         

-- line 14 ----------------------------------------
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .           namespace genetic {
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               /**
          .           .          .                    .               .          .                  .                .            .                * Execution kernel for a single program. We assume that the input data
          .           .          .                    .               .          .                  .                .            .                * is stored in column major format.
          .           .          .                    .               .          .                  .                .            .                */
          .           .          .                    .               .          .                  .                .            .               template <int MaxSize = MAX_STACK_SIZE>
         64 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                  0                0            0               void execute_kernel(const program_t d_progs, const float* data, float* y_pred,
          .           .          .                    .               .          .                  .                .            .                                   const uint64_t n_rows, const uint64_t n_progs) {
      3,578 ( 0.00%) 18 ( 0.31%) 3 ( 0.08%)       1,240 ( 0.00%)    141 ( 0.02%) 0              1,256 ( 0.00%)     221 ( 0.02%)  12 ( 0.01%)  #pragma omp parallel for schedule(dynamic)
          .           .          .                    .               .          .                  .                .            .                   for (uint64_t pid = 0; pid < n_progs; ++pid) {
  8,962,640 ( 0.16%)  2 ( 0.03%) 2 ( 0.06%)   3,014,860 ( 0.24%)     15 ( 0.00%) 0             40,970 ( 0.01%)       0            0                       for (uint64_t row_id = 0; row_id < n_rows; ++row_id) {
          .           .          .                    .               .          .                  .                .            .                           stack<float, MaxSize> eval_stack;
          .           .          .                    .               .          .                  .                .            .                           const program&        curr_p = d_progs[pid]; // Current program
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                           float res   = 0.0f;
 23,201,152 ( 0.42%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                  0                0            0                           float in1   = 0.0f;
  2,900,144 ( 0.05%)  0          0                    0               0          0                  0                0            0                           float in2   = 0.0f;
          .           .          .                    .               .          .                  .                .            .           
353,978,946 ( 6.47%)  0          0            2,900,144 ( 0.23%)  4,096 ( 0.46%) 0                  0                0            0                           for (int i = curr_p.len - 1; i >= 0; --i) {
          .           .          .                    .               .          .                  .                .            .                               const node& curr_node = curr_p.nodes[i];
336,578,082 ( 6.15%)  0          0          112,192,694 ( 8.94%) 26,405 ( 2.97%) 0                  0                0            0                               if (curr_node.flags.is_terminal_ == false) {
 77,119,460 ( 1.41%)  0          0                    0               0          0                  0                0            0                                   int ar = curr_node.flags.arity_;
          .           .          .                    .               .          .                  .                .            .                                   in1    = eval_stack.pop(); // Min arity of function is 1
154,238,920 ( 2.82%)  0          0                    0               0          0                  0                0            0                                   if (ar > 1)
          .           .          .                    .               .          .                  .                .            .                                       in2 = eval_stack.pop();
          .           .          .                    .               .          .                  .                .            .                               }
          .           .          .                    .               .          .                  .                .            .                               res = detail::evaluate_node_lookup(curr_node, data, n_rows, row_id, in1, in2);
          .           .          .                    .               .          .                  .                .            .                               // res = detail::evaluate_node(*curr_node, data, n_rows, row_id, in);
          .           .          .                    .               .          .                  .                .            .                               eval_stack.push(res);
          .           .          .                    .               .          .                  .                .            .                           }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                           // Outputs stored in col-major format
  5,800,288 ( 0.11%)  0          0            2,900,144 ( 0.23%)      6 ( 0.00%) 0          2,900,144 ( 0.70%) 181,293 (20.22%)   0                           y_pred[pid * n_rows + row_id] = eval_stack.pop();
          .           .          .                    .               .          .                  .                .            .                       }
          .           .          .                    .               .          .                  .                .            .                   }
          .           .          .                    .               .          .                  .                .            .               }
          .           .          .                    .               .          .                  .                .            .           
      2,613 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                718 ( 0.00%)       0            0               program::program()
      4,608 ( 0.00%)  0          0                    0               0          0              3,072 ( 0.00%)     255 ( 0.03%) 255 ( 0.25%)          : nodes(nullptr), len(0), depth(0), raw_fitness_(0.0f), metric(metric_t::mse),
      1,895 ( 0.00%)  0          0                    0               0          0              1,895 ( 0.00%)     255 ( 0.03%) 255 ( 0.25%)            mut_type(mutation_t::none) {
      1,536 ( 0.00%)  0          0                1,536 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
      9,728 ( 0.00%)  2 ( 0.03%) 0                    0               0          0                  0                0            0               program::~program() {
          .           .          .                    .               .          .                  .                .            .                   // delete[] nodes;
          .           .          .                    .               .          .                  .                .            .                   // delete[] nodes;
          .           .          .                    .               .          .                  .                .            .               }
          .           .          .                    .               .          .                  .                .            .           
     73,728 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0             49,152 ( 0.01%)       0            0               program::program(const program& src)
     32,768 ( 0.00%)  0          0               16,384 ( 0.00%)     16 ( 0.00%) 0             16,384 ( 0.00%)       0            0                   : len(src.len), depth(src.depth), raw_fitness_(src.raw_fitness_), metric(src.metric),
     16,384 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)       8,192 ( 0.00%)  4,096 ( 0.46%) 0              8,192 ( 0.00%)   2,556 ( 0.29%)   0                     mut_type(src.mut_type) {
      8,192 ( 0.00%)  0          0                8,192 ( 0.00%)      0          0                  0                0            0                   nodes = std::make_unique<node[]>(len);
          .           .          .                    .               .          .                  .                .            .           
     24,576 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)       8,192 ( 0.00%)      0          0                  0                0            0                   std::copy(src.nodes.get(), src.nodes.get() + src.len, nodes.get());
     65,536 ( 0.00%)  0          0               57,344 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
     78,328 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0             58,746 ( 0.01%)       0            0               program& program::operator=(const program& src) {
     19,582 ( 0.00%)  0          0                9,791 ( 0.00%)      0          0              9,791 ( 0.00%)       0            0                   len          = src.len;
     19,582 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)       9,791 ( 0.00%)  4,766 ( 0.54%) 0              9,791 ( 0.00%)      17 ( 0.00%)   0                   depth        = src.depth;
     19,582 ( 0.00%)  0          0                9,791 ( 0.00%)    682 ( 0.08%) 0              9,791 ( 0.00%)       0            0                   raw_fitness_ = src.raw_fitness_;
     19,582 ( 0.00%)  0          0                9,791 ( 0.00%)      0          0              9,791 ( 0.00%)   4,096 ( 0.46%)   0                   metric       = src.metric;
     19,582 ( 0.00%)  0          0                9,791 ( 0.00%)      0          0              9,791 ( 0.00%)     256 ( 0.03%)   0                   mut_type     = src.mut_type;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Copy nodes
          .           .          .                    .               .          .                  .                .            .                   // delete[] nodes;
          .           .          .                    .               .          .                  .                .            .                   // delete[] nodes;
          .           .          .                    .               .          .                  .                .            .                   nodes = std::make_unique<node[]>(len);
     29,373 ( 0.00%)  0          0                9,791 ( 0.00%)      0          0                  0                0            0                   std::copy(src.nodes.get(), src.nodes.get() + src.len, nodes.get());
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   return *this;
     88,119 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)      68,537 ( 0.01%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void compute_metric(int n_rows, int n_progs, const float* y, const float* y_pred,
         48 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                 16 ( 0.00%)       0            0                                   const float* w, float* score, const param& params) {
          .           .          .                    .               .          .                  .                .            .                   // Call appropriate metric function based on metric defined in params
         64 ( 0.00%)  0          0                   32 ( 0.00%)     16 ( 0.00%) 0                  0                0            0                   if (params.metric == metric_t::pearson) {
          .           .          .                    .               .          .                  .                .            .                       weightedPearson(n_rows, n_progs, y, y_pred, w, score);
         96 ( 0.00%)  0          0                   16 ( 0.00%)     16 ( 0.00%) 1 ( 0.01%)         0                0            0                   } else if (params.metric == metric_t::spearman) {
          .           .          .                    .               .          .                  .                .            .                       weightedSpearman(n_rows, n_progs, y, y_pred, w, score);
          .           .          .                    .               .          .                  .                .            .                   } else if (params.metric == metric_t::mae) {
          .           .          .                    .               .          .                  .                .            .                       meanAbsoluteError(n_rows, n_progs, y, y_pred, w, score);
          .           .          .                    .               .          .                  .                .            .                   } else if (params.metric == metric_t::mse) {
         48 ( 0.00%)  0          0                    0               0          0                  0                0            0                       meanSquareError(n_rows, n_progs, y, y_pred, w, score);
          .           .          .                    .               .          .                  .                .            .                   } else if (params.metric == metric_t::rmse) {
          .           .          .                    .               .          .                  .                .            .                       rootMeanSquareError(n_rows, n_progs, y, y_pred, w, score);
          .           .          .                    .               .          .                  .                .            .                   } else if (params.metric == metric_t::logloss) {
          .           .          .                    .               .          .                  .                .            .                       logLoss(n_rows, n_progs, y, y_pred, w, score);
          .           .          .                    .               .          .                  .                .            .                   } else {
          .           .          .                    .               .          .                  .                .            .                       // This should not be reachable
          .           .          .                    .               .          .                  .                .            .                   }
         32 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)          16 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void execute(const program_t& d_progs, const int n_rows, const int n_progs, const float* data,
          4 ( 0.00%)  0          0                    0               0          0                  0                0            0                            float* y_pred) {
         20 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           4 ( 0.00%)      0          0                  6 ( 0.00%)       0            0                   execute_kernel(d_progs, data, y_pred, static_cast<uint64_t>(n_rows),
          .           .          .                    .               .          .                  .                .            .                                  static_cast<uint64_t>(n_progs));
         10 ( 0.00%)  0          0                    6 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void find_fitness(program_t d_prog, float* score, const param& params, const int n_rows,
          .           .          .                    .               .          .                  .                .            .                                 const float* data, const float* y, const float* sample_weights) {
          .           .          .                    .               .          .                  .                .            .                   // Compute predicted values
          .           .          .                    .               .          .                  .                .            .                   std::vector<float> y_pred(n_rows);
          .           .          .                    .               .          .                  .                .            .                   execute(d_prog, n_rows, 1, data, y_pred.data());
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Compute error
          .           .          .                    .               .          .                  .                .            .                   compute_metric(n_rows, 1, y, y_pred.data(), sample_weights, score, params);
          .           .          .                    .               .          .                  .                .            .               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void find_batched_fitness(int n_progs, program_t d_progs, float* score, const param& params,
          .           .          .                    .               .          .                  .                .            .                                         const int n_rows, const float* data, const float* y,
        272 ( 0.00%)  3 ( 0.05%) 2 ( 0.06%)          48 ( 0.00%)      0          0                128 ( 0.00%)       0            0                                         const float* sample_weights) {
         32 ( 0.00%)  0          0                    0               0          0                  0                0            0                   std::vector<float> y_pred((uint64_t)n_rows * (uint64_t)n_progs);
          .           .          .                    .               .          .                  .                .            .                   execute(d_progs, n_rows, n_progs, data, y_pred.data());
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Compute error
        192 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)          64 ( 0.00%)     16 ( 0.00%) 0                 32 ( 0.00%)       0            0                   compute_metric(n_rows, n_progs, y, y_pred.data(), sample_weights, score, params);
        112 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)          96 ( 0.00%)     16 ( 0.00%) 0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void set_fitness(program& h_prog, const param& params, const int n_rows, const float* data,
          .           .          .                    .               .          .                  .                .            .                                const float* y, const float* sample_weights) {
          .           .          .                    .               .          .                  .                .            .                   std::vector<float> score(1);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   find_fitness(&h_prog, score.data(), params, n_rows, data, y, sample_weights);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Update host and device score for program
          .           .          .                    .               .          .                  .                .            .                   h_prog.raw_fitness_ = score[0];
          .           .          .                    .               .          .                  .                .            .               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void set_batched_fitness(int n_progs, std::vector<program>& h_progs, const param& params,
          .           .          .                    .               .          .                  .                .            .                                        const int n_rows, const float* data, const float* y,
        176 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)          16 ( 0.00%)      0          0                 96 ( 0.00%)       0            0                                        const float* sample_weights) {
          .           .          .                    .               .          .                  .                .            .                   std::vector<float> score(n_progs);
          .           .          .                    .               .          .                  .                .            .           
        176 ( 0.00%) 16 ( 0.28%) 1 ( 0.03%)          64 ( 0.00%)      0          0                 48 ( 0.00%)       0            0                   find_batched_fitness(n_progs, h_progs.data(), score.data(), params, n_rows, data, y,
          .           .          .                    .               .          .                  .                .            .                                        sample_weights);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Update scores on host and device
          .           .          .                    .               .          .                  .                .            .                   // TODO: Find a way to reduce the number of implicit memory transfers
     32,912 ( 0.00%)  0          0                   32 ( 0.00%)     32 ( 0.00%) 0                  0                0            0                   for (auto i = 0; i < n_progs; ++i) {
     16,384 ( 0.00%)  0          0                8,192 ( 0.00%)    500 ( 0.06%) 0              8,192 ( 0.00%)   4,096 ( 0.46%)   0                       h_progs[i].raw_fitness_ = score[i];
          .           .          .                    .               .          .                  .                .            .                   }
        112 ( 0.00%)  0          0                   96 ( 0.00%)     16 ( 0.00%) 0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               float get_fitness(const program& prog, const param& params) {
          .           .          .                    .               .          .                  .                .            .                   int   crit    = params.criterion();
          .           .          .                    .               .          .                  .                .            .                   float penalty = params.parsimony_coefficient * prog.len * (2 * crit - 1);
          .           .          .                    .               .          .                  .                .            .                   return (prog.raw_fitness_ - penalty);
          .           .          .                    .               .          .                  .                .            .               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               /**
          .           .          .                    .               .          .                  .                .            .                * @brief Get a random subtree of the current program nodes (on CPU)
          .           .          .                    .               .          .                  .                .            .                *
          .           .          .                    .               .          .                  .                .            .                * @param pnodes  AST represented as a list of nodes
          .           .          .                    .               .          .                  .                .            .                * @param len     The total number of nodes in the AST
          .           .          .                    .               .          .                  .                .            .                * @param rng     Random number generator for subtree selection
          .           .          .                    .               .          .                  .                .            .                * @return A tuple [first,last) which contains the required subtree
          .           .          .                    .               .          .                  .                .            .                */
    173,602 ( 0.00%)  2 ( 0.03%) 2 ( 0.06%)      13,354 ( 0.00%)      0          0            106,832 ( 0.03%)       0            0               std::pair<int, int> get_subtree(node* pnodes, int len, PhiloxEngine& rng) {
          .           .          .                    .               .          .                  .                .            .                   int start, end;
          .           .          .                    .               .          .                  .                .            .                   start = end = 0;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Specify RNG
          .           .          .                    .               .          .                  .                .            .                   uniform_real_distribution_custom<float> dist_uniform(0.0f, 1.0f);
          .           .          .                    .               .          .                  .                .            .                   float                                   bound = dist_uniform(rng);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Specify subtree start probs acc to Koza's selection approach
     13,354 ( 0.00%)  0          0                    0               0          0                  0                0            0                   std::vector<float> node_probs(len, 0.1);
     80,124 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)      13,354 ( 0.00%)      0          0             13,354 ( 0.00%)       0            0                   float              sum = 0.1 * len;
          .           .          .                    .               .          .                  .                .            .           
  2,271,108 ( 0.04%)  0          0               13,354 ( 0.00%)      0          0                  0                0            0                   for (int i = 0; i < len; ++i) {
  2,164,276 ( 0.04%)  0          0                    0               0          0            541,069 ( 0.13%)       0            0                       if (pnodes[i].is_nonterminal()) {
    372,802 ( 0.01%)  0          0                    0               0          0            372,802 ( 0.09%)       0            0                           node_probs[i] = 0.9;
  2,236,812 ( 0.04%)  1 ( 0.02%) 1 ( 0.03%)     745,604 ( 0.06%)      0          0            372,802 ( 0.09%)       0            0                           sum += 0.8;
          .           .          .                    .               .          .                  .                .            .                       }
          .           .          .                    .               .          .                  .                .            .                   }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Normalize vector
  1,623,207 ( 0.03%)  0          0                    0               0          0                  0                0            0                   for (int i = 0; i < len; ++i) {
  1,623,207 ( 0.03%)  0          0            1,082,138 ( 0.09%)      0          0            541,069 ( 0.13%)       0            0                       node_probs[i] /= sum;
          .           .          .                    .               .          .                  .                .            .                   }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Compute cumulative sum
          .           .          .                    .               .          .                  .                .            .                   std::partial_sum(node_probs.begin(), node_probs.end(), node_probs.begin());
          .           .          .                    .               .          .                  .                .            .           
     13,354 ( 0.00%)  0          0                    0               0          0             13,354 ( 0.00%)       0            0                   start = std::lower_bound(node_probs.begin(), node_probs.end(), bound) - node_probs.begin();
          .           .          .                    .               .          .                  .                .            .                   end   = start;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Iterate until all function arguments are satisfied in current subtree
    106,832 ( 0.00%)  0          0                    0               0          0             13,354 ( 0.00%)       0            0                   int num_args = 1;
    595,023 ( 0.01%)  1 ( 0.02%) 1 ( 0.03%)      26,708 ( 0.00%)      0          0                  0                0            0                   while (num_args > end - start) {
    227,326 ( 0.00%) 14 ( 0.24%) 1 ( 0.03%)           0               0          0            113,663 ( 0.03%)       0            0                       node curr;
    340,989 ( 0.01%)  0          0                    0               0          0            113,663 ( 0.03%)       0            0                       curr = pnodes[end];
    454,652 ( 0.01%)  0          0                    0               0          0            113,663 ( 0.03%)       0            0                       if (curr.is_nonterminal())
    288,888 ( 0.01%)  0          0                    0               0          0             72,222 ( 0.02%)       0            0                           num_args += curr.arity();
    113,663 ( 0.00%)  0          0              113,663 ( 0.01%)      0          0                  0                0            0                       ++end;
          .           .          .                    .               .          .                  .                .            .                   }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   return std::make_pair(start, end);
    160,248 ( 0.00%)  0          0              120,186 ( 0.01%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
     87,893 ( 0.00%)  2 ( 0.03%) 2 ( 0.06%)       6,761 ( 0.00%)      0          0             54,088 ( 0.01%)       0            0               int get_depth(const program& p_out) {
      6,761 ( 0.00%)  0          0                    0               0          0              6,761 ( 0.00%)       0            0                   int             depth = 0;
          .           .          .                    .               .          .                  .                .            .                   std::stack<int> arity_stack;
  1,176,021 ( 0.02%)  0          0              577,869 ( 0.05%)      0          0                  0                0            0                   for (auto i = 0; i < p_out.len; ++i) {
    571,166 ( 0.01%)  0          0                    0               0          0            285,583 ( 0.07%)       0            0                       node curr(p_out.nodes[i]);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                       // Update depth
          .           .          .                    .               .          .                  .                .            .                       int sz = arity_stack.size();
          .           .          .                    .               .          .                  .                .            .                       depth  = std::max(depth, sz);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                       // Update stack
  1,142,332 ( 0.02%)  0          0                    0               0          0            285,583 ( 0.07%)       0            0                       if (curr.is_nonterminal()) {
    590,442 ( 0.01%)  0          0                    0               0          0            393,628 ( 0.10%)       0            0                           arity_stack.push(curr.arity());
          .           .          .                    .               .          .                  .                .            .                       } else {
          .           .          .                    .               .          .                  .                .            .                           // Only triggered for a depth 0 node
    177,538 ( 0.00%)  0          0               88,769 ( 0.01%)      0          0                  0                0            0                           if (arity_stack.empty())
          .           .          .                    .               .          .                  .                .            .                               break;
          .           .          .                    .               .          .                  .                .            .           
     88,740 ( 0.00%)  0          0               88,740 ( 0.01%)      0          0                  0                0            0                           int e = arity_stack.top();
          .           .          .                    .               .          .                  .                .            .                           arity_stack.pop();
    177,480 ( 0.00%)  0          0                    0               0          0             88,740 ( 0.02%)       0            0                           arity_stack.push(e - 1);
          .           .          .                    .               .          .                  .                .            .           
    836,466 ( 0.02%)  0          0              278,822 ( 0.02%)      0          0                  0                0            0                           while (arity_stack.top() == 0) {
          .           .          .                    .               .          .                  .                .            .                               arity_stack.pop();
    393,628 ( 0.01%)  0          0              196,814 ( 0.02%)      0          0                  0                0            0                               if (arity_stack.empty())
          .           .          .                    .               .          .                  .                .            .                                   break;
          .           .          .                    .               .          .                  .                .            .           
    190,082 ( 0.00%)  0          0              190,082 ( 0.02%)      0          0                  0                0            0                               e = arity_stack.top();
          .           .          .                    .               .          .                  .                .            .                               arity_stack.pop();
    380,164 ( 0.01%)  0          0                    0               0          0            190,082 ( 0.05%)       0            0                               arity_stack.push(e - 1);
          .           .          .                    .               .          .                  .                .            .                           }
          .           .          .                    .               .          .                  .                .            .                       }
          .           .          .                    .               .          .                  .                .            .                   }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   return depth;
     81,132 ( 0.00%) 14 ( 0.24%) 1 ( 0.03%)      67,610 ( 0.01%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
     12,194 ( 0.00%) 18 ( 0.31%) 2 ( 0.06%)         871 ( 0.00%)      0          0              7,839 ( 0.00%)       1 ( 0.00%)   0               void build_program(program& p_out, const param& params, PhiloxEngine& rng) {
          .           .          .                    .               .          .                  .                .            .                   // Define data structures needed for tree
          .           .          .                    .               .          .                  .                .            .                   std::stack<int>   arity_stack;
          .           .          .                    .               .          .                  .                .            .                   std::vector<node> nodelist;
          .           .          .                    .               .          .                  .                .            .                   nodelist.reserve(1 << (MAX_STACK_SIZE));
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Specify Distributions with parameters
        871 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)           0               0          0                871 ( 0.00%)       1 ( 0.00%)   0                   uniform_int_distribution_custom<int>    dist_function(0, params.function_set.size() - 1);
        871 ( 0.00%)  0          0                  871 ( 0.00%)      0          0                  0                0            0                   uniform_int_distribution_custom<int>    dist_initDepth(params.init_depth[0],
      1,742 ( 0.00%)  0          0                1,742 ( 0.00%)    136 ( 0.02%) 0                  0                0            0                                                                          params.init_depth[1]);
      2,613 ( 0.00%)  0          0                1,742 ( 0.00%)    149 ( 0.02%) 0                871 ( 0.00%)       0            0                   uniform_int_distribution_custom<int>    dist_terminalChoice(0, params.num_features);
      1,742 ( 0.00%)  0          0                  871 ( 0.00%)      0          0                871 ( 0.00%)       0            0                   uniform_real_distribution_custom<float> dist_constVal(params.const_range[0],
      2,613 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)       1,742 ( 0.00%)      0          0                871 ( 0.00%)       0            0                                                                         params.const_range[1]);
      2,613 ( 0.00%)  0          0                1,742 ( 0.00%)      0          0                871 ( 0.00%)       0            0                   bernoulli_distribution_custom           dist_nodeChoice(params.terminalRatio);
          .           .          .                    .               .          .                  .                .            .                   bernoulli_distribution_custom           dist_coinToss(0.5);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Initialize nodes
          .           .          .                    .               .          .                  .                .            .                   int        max_depth = dist_initDepth(rng);
      3,484 ( 0.00%)  0          0                2,613 ( 0.00%)      0          0                  0                0            0                   node::type func      = params.function_set[dist_function(rng)];
      3,484 ( 0.00%)  0          0                  871 ( 0.00%)    202 ( 0.02%) 0                871 ( 0.00%)       0            0                   node       curr_node(func);
          .           .          .                    .               .          .                  .                .            .                   nodelist.push_back(curr_node);
      2,613 ( 0.00%)  0          0                    0               0          0              1,742 ( 0.00%)       0            0                   arity_stack.push(curr_node.arity());
          .           .          .                    .               .          .                  .                .            .           
      1,742 ( 0.00%)  0          0                  871 ( 0.00%)      0          0                871 ( 0.00%)       0            0                   init_method_t method = params.init_method;
      1,742 ( 0.00%)  0          0                    0               0          0                  0                0            0                   if (method == init_method_t::half_and_half) {
          .           .          .                    .               .          .                  .                .            .                       // Choose either grow or full for this tree
          .           .          .                    .               .          .                  .                .            .                       bool choice = dist_coinToss(rng);
      5,226 ( 0.00%)  0          0                  871 ( 0.00%)      2 ( 0.00%) 1 ( 0.01%)       871 ( 0.00%)       0            0                       method      = choice ? init_method_t::grow : init_method_t::full;
          .           .          .                    .               .          .                  .                .            .                   }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Fill tree
     22,737 ( 0.00%)  0          0                    0               0          0                  0                0            0                   while (!arity_stack.empty()) {
          .           .          .                    .               .          .                  .                .            .                       int depth        = arity_stack.size();
     54,665 ( 0.00%)  0          0               21,866 ( 0.00%)    224 ( 0.03%) 0             10,933 ( 0.00%)       0            0                       p_out.depth      = std::max(depth, p_out.depth);
          .           .          .                    .               .          .                  .                .            .                       bool node_choice = dist_nodeChoice(rng);
          .           .          .                    .               .          .                  .                .            .           
     44,360 ( 0.00%)  0          0               11,247 ( 0.00%)      0          0                  0                0            0                       if ((node_choice == false || method == init_method_t::full) && depth < max_depth) {
          .           .          .                    .               .          .                  .                .            .                           // Add a function to node list
     66,820 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)      26,728 ( 0.00%)      0          0             13,364 ( 0.00%)       0            0                           curr_node = node(params.function_set[dist_function(rng)]);
          .           .          .                    .               .          .                  .                .            .                           nodelist.push_back(curr_node);
     20,046 ( 0.00%)  0          0                    0               0          0             13,364 ( 0.00%)       0            0                           arity_stack.push(curr_node.arity());
          .           .          .                    .               .          .                  .                .            .                       } else {
          .           .          .                    .               .          .                  .                .            .                           // Add terminal
          .           .          .                    .               .          .                  .                .            .                           int terminal_choice = dist_terminalChoice(rng);
     12,753 ( 0.00%)  0          0                8,502 ( 0.00%)      0          0                  0                0            0                           if (terminal_choice == params.num_features) {
          .           .          .                    .               .          .                  .                .            .                               // Add constant
          .           .          .                    .               .          .                  .                .            .                               float val = dist_constVal(rng);
      1,110 ( 0.00%)  0          0                    0               0          0                370 ( 0.00%)       0            0                               curr_node = node(val);
          .           .          .                    .               .          .                  .                .            .                           } else {
          .           .          .                    .               .          .                  .                .            .                               // Add variable
          .           .          .                    .               .          .                  .                .            .                               int fid   = terminal_choice;
     24,396 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)           0               0          0              8,132 ( 0.00%)       0            0                               curr_node = node(fid);
          .           .          .                    .               .          .                  .                .            .                           }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                           // Modify nodelist
          .           .          .                    .               .          .                  .                .            .                           nodelist.push_back(curr_node);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                           // Modify stack
      4,251 ( 0.00%)  0          0                4,251 ( 0.00%)      0          0                  0                0            0                           int e = arity_stack.top();
          .           .          .                    .               .          .                  .                .            .                           arity_stack.pop();
      8,502 ( 0.00%)  0          0                    0               0          0              4,251 ( 0.00%)       0            0                           arity_stack.push(e - 1);
     32,799 ( 0.00%)  0          0               10,933 ( 0.00%)      0          0                  0                0            0                           while (arity_stack.top() == 0) {
          .           .          .                    .               .          .                  .                .            .                               arity_stack.pop();
     15,106 ( 0.00%)  0          0                7,553 ( 0.00%)      0          0                  0                0            0                               if (arity_stack.empty()) {
          .           .          .                    .               .          .                  .                .            .                                   break;
          .           .          .                    .               .          .                  .                .            .                               }
          .           .          .                    .               .          .                  .                .            .           
      6,682 ( 0.00%)  0          0                6,682 ( 0.00%)      0          0                  0                0            0                               e = arity_stack.top();
          .           .          .                    .               .          .                  .                .            .                               arity_stack.pop();
     13,364 ( 0.00%)  0          0                    0               0          0              6,682 ( 0.00%)       0            0                               arity_stack.push(e - 1);
          .           .          .                    .               .          .                  .                .            .                           }
          .           .          .                    .               .          .                  .                .            .                       }
          .           .          .                    .               .          .                  .                .            .                   }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Set new program parameters - need to do a copy as
          .           .          .                    .               .          .                  .                .            .                   // nodelist will be deleted using RAII semantics
          .           .          .                    .               .          .                  .                .            .                   p_out.nodes = std::make_unique<node[]>(nodelist.size());
          .           .          .                    .               .          .                  .                .            .                   std::copy(nodelist.begin(), nodelist.end(), p_out.nodes.get());
          .           .          .                    .               .          .                  .                .            .           
      2,613 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)       1,742 ( 0.00%)      0          0                871 ( 0.00%)       0            0                   p_out.len          = nodelist.size();
      2,613 ( 0.00%)  0          0                1,742 ( 0.00%)    165 ( 0.02%) 0                871 ( 0.00%)       0            0                   p_out.metric       = params.metric;
        871 ( 0.00%)  0          0                    0               0          0                871 ( 0.00%)       0            0                   p_out.raw_fitness_ = 0.0f;
      9,581 ( 0.00%)  0          0                7,839 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void point_mutation(const program& prog, program& p_out, const param& params,
      1,170 ( 0.00%) 30 ( 0.52%) 2 ( 0.06%)          78 ( 0.00%)      0          0                624 ( 0.00%)       0            0                                   PhiloxEngine& rng) {
          .           .          .                    .               .          .                  .                .            .                   // deep-copy program
        156 ( 0.00%)  0          0                    0               0          0                 78 ( 0.00%)       0            0                   p_out = prog;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Specify RNGs
          .           .          .                    .               .          .                  .                .            .                   uniform_real_distribution_custom<float> dist_uniform(0.0f, 1.0f);
        156 ( 0.00%)  0          0                   78 ( 0.00%)     36 ( 0.00%) 0                 78 ( 0.00%)       0            0                   uniform_int_distribution_custom<int>    dist_terminalChoice(0, params.num_features);
        156 ( 0.00%)  0          0                   78 ( 0.00%)      0          0                 78 ( 0.00%)       0            0                   uniform_real_distribution_custom<float> dist_constantVal(params.const_range[0],
        156 ( 0.00%)  0          0                   78 ( 0.00%)     30 ( 0.00%) 0                 78 ( 0.00%)       0            0                                                                            params.const_range[1]);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Fill with uniform numbers
        156 ( 0.00%) 15 ( 0.26%) 1 ( 0.03%)         156 ( 0.00%)      0          0                  0                0            0                   std::vector<float> node_probs(p_out.len);
          .           .          .                    .               .          .                  .                .            .                   std::generate(node_probs.begin(), node_probs.end(),
          .           .          .                    .               .          .                  .                .            .                                 [&dist_uniform, &rng] { return dist_uniform(rng); });
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Mutate nodes
        156 ( 0.00%)  0          0                  156 ( 0.00%)      0          0                  0                0            0                   int len = p_out.len;
     15,178 ( 0.00%)  0          0                3,697 ( 0.00%)      0          0                 78 ( 0.00%)       0            0                   for (int i = 0; i < len; ++i) {
      7,238 ( 0.00%)  0          0                    0               0          0              3,619 ( 0.00%)       0            0                       node curr(prog.nodes[i]);
          .           .          .                    .               .          .                  .                .            .           
     10,857 ( 0.00%)  0          0                7,238 ( 0.00%)     38 ( 0.00%) 0                  0                0            0                       if (node_probs[i] < params.p_point_replace) {
        744 ( 0.00%)  0          0                    0               0          0                186 ( 0.00%)       0            0                           if (curr.is_terminal()) {
          .           .          .                    .               .          .                  .                .            .                               int choice = dist_terminalChoice(rng);
          .           .          .                    .               .          .                  .                .            .           
        108 ( 0.00%)  0          0                   54 ( 0.00%)      0          0                  0                0            0                               if (choice == params.num_features) {
          .           .          .                    .               .          .                  .                .            .                                   // Add a randomly generated constant
         24 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                  6 ( 0.00%)       0            0                                   curr = node(dist_constantVal(rng));
          .           .          .                    .               .          .                  .                .            .                               } else {
          .           .          .                    .               .          .                  .                .            .                                   // Add a variable with fid=choice
        354 ( 0.00%)  0          0                    0               0          0                102 ( 0.00%)       0            0                                   curr = node(choice);
          .           .          .                    .               .          .                  .                .            .                               }
        528 ( 0.00%)  3 ( 0.05%) 0                    0               0          0                132 ( 0.00%)       0            0                           } else if (curr.is_nonterminal()) {
          .           .          .                    .               .          .                  .                .            .                               // Replace current function with another function of the same arity
        264 ( 0.00%)  0          0                    0               0          0                132 ( 0.00%)       0            0                               int ar = curr.arity();
          .           .          .                    .               .          .                  .                .            .                               // CUML_LOG_DEBUG("Arity is %d, curr function is
          .           .          .                    .               .          .                  .                .            .                               // %d",ar,static_cast<std::underlying_type<node::type>::type>(curr.t));
        528 ( 0.00%)  0          0                    0               0          0                  0                0            0                               std::vector<node::type>              fset = params.arity_set[ar];
        132 ( 0.00%)  0          0                    0               0          0                132 ( 0.00%)       0            0                               uniform_int_distribution_custom<int> dist_fset(0, fset.size() - 1);
          .           .          .                    .               .          .                  .                .            .                               int                                  choice = dist_fset(rng);
      1,320 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)         396 ( 0.00%)      0          0                264 ( 0.00%)       0            0                               curr                                        = node(fset[choice]);
          .           .          .                    .               .          .                  .                .            .                           }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                           // Update p_out with updated value
        372 ( 0.00%)  0          0                    0               0          0                186 ( 0.00%)       0            0                           p_out.nodes[i] = curr;
          .           .          .                    .               .          .                  .                .            .                       }
          .           .          .                    .               .          .                  .                .            .                   }
        546 ( 0.00%)  0          0                  468 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void crossover(const program& prog, const program& donor, program& p_out,
     91,350 ( 0.00%) 14 ( 0.24%) 1 ( 0.03%)           0               0          0             52,200 ( 0.01%)       0            0                              [[maybe_unused]] const param& params, PhiloxEngine& rng) {
          .           .          .                    .               .          .                  .                .            .                   // Get a random subtree of prog to replace
     19,575 ( 0.00%)  0          0               13,050 ( 0.00%)  5,125 ( 0.58%) 0              6,525 ( 0.00%)       0            0                   std::pair<int, int> prog_slice = get_subtree(prog.nodes.get(), prog.len, rng);
      6,525 ( 0.00%)  0          0                    0               0          0              6,525 ( 0.00%)       0            0                   int                 prog_start = prog_slice.first;
     19,575 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0              6,525 ( 0.00%)       0            0                   int                 prog_end   = prog_slice.second;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Set metric of output program
     13,050 ( 0.00%)  0          0                6,525 ( 0.00%)  2,693 ( 0.30%) 0              6,525 ( 0.00%)       0            0                   p_out.metric = prog.metric;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // MAX_STACK_SIZE can only handle tree of depth MAX_STACK_SIZE -
          .           .          .                    .               .          .                  .                .            .                   // max(func_arity=2) + 1 Thus we continuously hoist the donor subtree. Actual
          .           .          .                    .               .          .                  .                .            .                   // indices in donor
      6,525 ( 0.00%)  0          0                    0               0          0              6,525 ( 0.00%)       0            0                   int donor_start  = 0;
     13,050 ( 0.00%)  0          0                6,525 ( 0.00%)  4,820 ( 0.54%) 0              6,525 ( 0.00%)       0            0                   int donor_end    = donor.len;
      6,525 ( 0.00%) 15 ( 0.26%) 1 ( 0.03%)           0               0          0              6,525 ( 0.00%)       0            0                   int output_depth = 0;
          .           .          .                    .               .          .                  .                .            .                   do {
          .           .          .                    .               .          .                  .                .            .                       // Get donor subtree
          .           .          .                    .               .          .                  .                .            .                       std::pair<int, int> donor_slice =
     66,930 ( 0.00%) 15 ( 0.26%) 1 ( 0.03%)      40,158 ( 0.00%)      0          0              6,693 ( 0.00%)       0            0                           get_subtree(donor.nodes.get() + donor_start, donor_end - donor_start, rng);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                       // Get indices w.r.t current subspace [donor_start,donor_end)
          .           .          .                    .               .          .                  .                .            .                       int donor_substart = donor_slice.first;
     20,079 ( 0.00%)  0          0                    0               0          0                  0                0            0                       int donor_subend   = donor_slice.second;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                       // Update relative indices to global indices
     13,386 ( 0.00%)  0          0                    0               0          0              6,693 ( 0.00%)       0            0                       donor_substart += donor_start;
     13,386 ( 0.00%)  0          0                    0               0          0              6,693 ( 0.00%)       0            0                       donor_subend += donor_start;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                       // Update to new subspace
          .           .          .                    .               .          .                  .                .            .                       donor_start = donor_substart;
          .           .          .                    .               .          .                  .                .            .                       donor_end   = donor_subend;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                       // Evolve on current subspace
     60,237 ( 0.00%)  0          0               20,079 ( 0.00%)      0          0             13,386 ( 0.00%)       0            0                       p_out.len = (prog_start) + (donor_end - donor_start) + (prog.len - prog_end);
          .           .          .                    .               .          .                  .                .            .                       // delete[] p_out.nodes;
      6,693 ( 0.00%) 15 ( 0.26%) 1 ( 0.03%)           0               0          0                  0                0            0                       p_out.nodes = std::make_unique<node[]>(p_out.len);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                       // Copy slices using std::copy
     32,625 ( 0.00%)  0          0                    0               0          0             13,050 ( 0.00%)       0            0                       std::copy(prog.nodes.get(), prog.nodes.get() + prog_start, p_out.nodes.get());
     80,316 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)      33,465 ( 0.00%)      0          0              6,693 ( 0.00%)       0            0                       std::copy(donor.nodes.get() + donor_start, donor.nodes.get() + donor_end,
          .           .          .                    .               .          .                  .                .            .                                 p_out.nodes.get() + prog_start);
     72,951 ( 0.00%)  0          0               20,079 ( 0.00%)      0          0              6,525 ( 0.00%)       0            0                       std::copy(prog.nodes.get() + prog_end, prog.nodes.get() + prog.len,
     20,079 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)      13,386 ( 0.00%)      0          0                  0                0            0                                 p_out.nodes.get() + (prog_start) + (donor_end - donor_start));
          .           .          .                    .               .          .                  .                .            .           
     13,386 ( 0.00%)  0          0                    0               0          0              6,693 ( 0.00%)       0            0                       output_depth = get_depth(p_out);
     13,386 ( 0.00%)  0          0                    0               0          0                  0                0            0                   } while (output_depth >= MAX_STACK_SIZE);
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Set the depth of the final program
      6,525 ( 0.00%)  0          0                    0               0          0              6,525 ( 0.00%)       0            0                   p_out.depth = output_depth;
     52,200 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)      45,675 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void subtree_mutation(const program& prog, program& p_out, const param& params,
      5,026 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)         359 ( 0.00%)      0          0              2,154 ( 0.00%)       0            0                                     PhiloxEngine& rng) {
          .           .          .                    .               .          .                  .                .            .                   // Generate a random program and perform crossover
          .           .          .                    .               .          .                  .                .            .                   program new_program;
      1,795 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                359 ( 0.00%)       0            0                   build_program(new_program, params, rng);
      2,154 ( 0.00%)  0          0                    0               0          0                359 ( 0.00%)       0            0                   crossover(prog, new_program, p_out, params, rng);
      2,154 ( 0.00%)  0          0                1,795 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .               void hoist_mutation(const program& prog, program& p_out, [[maybe_unused]] const param& params,
        816 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                476 ( 0.00%)       0            0                                   PhiloxEngine& rng) {
          .           .          .                    .               .          .                  .                .            .                   // Replace program subtree with a random sub-subtree
          .           .          .                    .               .          .                  .                .            .           
        340 ( 0.00%)  0          0                  136 ( 0.00%)     52 ( 0.01%) 0                 68 ( 0.00%)       0            0                   std::pair<int, int> prog_slice = get_subtree(prog.nodes.get(), prog.len, rng);
          .           .          .                    .               .          .                  .                .            .                   int                 prog_start = prog_slice.first;
        204 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)           0               0          0                 68 ( 0.00%)       0            0                   int                 prog_end   = prog_slice.second;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   std::pair<int, int> sub_slice =
        748 ( 0.00%)  0          0                   68 ( 0.00%)      0          0                136 ( 0.00%)       0            0                       get_subtree(prog.nodes.get() + prog_start, prog_end - prog_start, rng);
          .           .          .                    .               .          .                  .                .            .                   int sub_start = sub_slice.first;
        136 ( 0.00%)  0          0                    0               0          0                  0                0            0                   int sub_end   = sub_slice.second;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Update subtree indices to global indices
        136 ( 0.00%)  0          0                    0               0          0                 68 ( 0.00%)       0            0                   sub_start += prog_start;
        136 ( 0.00%)  0          0                    0               0          0                 68 ( 0.00%)       0            0                   sub_end += prog_start;
          .           .          .                    .               .          .                  .                .            .           
        544 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)          68 ( 0.00%)      0          0                136 ( 0.00%)       0            0                   p_out.len    = (prog_start) + (sub_end - sub_start) + (prog.len - prog_end);
         68 ( 0.00%)  0          0                    0               0          0                  0                0            0                   p_out.nodes  = std::make_unique<node[]>(p_out.len);
        204 ( 0.00%)  0          0                  136 ( 0.00%)     30 ( 0.00%) 0                 68 ( 0.00%)       0            0                   p_out.metric = prog.metric;
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Copy node slices using std::copy
          .           .          .                    .               .          .                  .                .            .                   std::copy(prog.nodes.get(), prog.nodes.get() + prog_start, p_out.nodes.get());
        544 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)         136 ( 0.00%)      0          0                  0                0            0                   std::copy(prog.nodes.get() + sub_start, prog.nodes.get() + sub_end,
          .           .          .                    .               .          .                  .                .            .                             p_out.nodes.get() + prog_start);
        544 ( 0.00%)  0          0                  136 ( 0.00%)      0          0                  0                0            0                   std::copy(prog.nodes.get() + prog_end, prog.nodes.get() + prog.len,
        204 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)         136 ( 0.00%)      0          0                  0                0            0                             p_out.nodes.get() + (prog_start) + (sub_end - sub_start));
          .           .          .                    .               .          .                  .                .            .           
          .           .          .                    .               .          .                  .                .            .                   // Update depth
        272 ( 0.00%)  0          0                   68 ( 0.00%)      0          0                136 ( 0.00%)       0            0                   p_out.depth = get_depth(p_out);
        544 ( 0.00%)  0          0                  476 ( 0.00%)      0          0                  0                0            0               }
          .           .          .                    .               .          .                  .                .            .           
          3 ( 0.00%)  0          0                    1 ( 0.00%)      0          0                  1 ( 0.00%)       0            0           } // namespace genetic

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_deque.h
--------------------------------------------------------------------------------
Ir                 I1mr        ILmr       Dr               D1mr       DLmr       Dw               D1mw         DLmw       

-- line 144 ----------------------------------------
        .           .          .                .          .          .                .            .          .                 _Elt_pointer _M_last;
        .           .          .                .          .          .                .            .          .                 _Map_pointer _M_node;
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 : _M_cur(__x), _M_first(*__y),
        .           .          .                .          .          .                .            .          .           	_M_last(*__y + _S_buffer_size()), _M_node(__y) { }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_iterator() _GLIBCXX_NOEXCEPT
   61,072 ( 0.00%) 30 ( 0.52%) 5 ( 0.14%)       0          0          0           61,072 ( 0.01%)   0          0                 : _M_cur(), _M_first(), _M_last(), _M_node() { }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .           #if __cplusplus < 201103L
        .           .          .                .          .          .                .            .          .                 // Conversion from iterator to const_iterator.
        .           .          .                .          .          .                .            .          .                 _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 : _M_cur(__x._M_cur), _M_first(__x._M_first),
        .           .          .                .          .          .                .            .          .           	_M_last(__x._M_last), _M_node(__x._M_node) { }
        .           .          .                .          .          .                .            .          .           #else
        .           .          .                .          .          .                .            .          .                 // Conversion from iterator to const_iterator.
-- line 160 ----------------------------------------
-- line 161 ----------------------------------------
        .           .          .                .          .          .                .            .          .                 template<typename _Iter,
        .           .          .                .          .          .                .            .          .           	       typename = _Require<is_same<_Self, const_iterator>,
        .           .          .                .          .          .                .            .          .           				   is_same<_Iter, iterator>>>
        .           .          .                .          .          .                .            .          .                  _Deque_iterator(const _Iter& __x) noexcept
        .           .          .                .          .          .                .            .          .                  : _M_cur(__x._M_cur), _M_first(__x._M_first),
        .           .          .                .          .          .                .            .          .           	 _M_last(__x._M_last), _M_node(__x._M_node) { }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_iterator(const _Deque_iterator& __x) noexcept
  289,869 ( 0.01%)  2 ( 0.03%) 2 ( 0.06%) 289,869 ( 0.02%) 0          0                0            0          0                  : _M_cur(__x._M_cur), _M_first(__x._M_first),
  486,697 ( 0.01%)  0          0          486,697 ( 0.04%) 0          0                0            0          0           	 _M_last(__x._M_last), _M_node(__x._M_node) { }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_iterator& operator=(const _Deque_iterator&) = default;
        .           .          .                .          .          .                .            .          .           #endif
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 iterator
        .           .          .                .          .          .                .            .          .                 _M_const_cast() const _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 { return iterator(_M_cur, _M_node); }
        .           .          .                .          .          .                .            .          .           
-- line 178 ----------------------------------------
-- line 202 ----------------------------------------
        .           .          .                .          .          .                .            .          .           	_Self __tmp = *this;
        .           .          .                .          .          .                .            .          .           	++*this;
        .           .          .                .          .          .                .            .          .           	return __tmp;
        .           .          .                .          .          .                .            .          .                 }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Self&
        .           .          .                .          .          .                .            .          .                 operator--() _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 {
1,159,401 ( 0.02%)  3 ( 0.05%) 3 ( 0.08%) 579,688 ( 0.05%) 0          0                0            0          0           	if (_M_cur == _M_first)
        .           .          .                .          .          .                .            .          .           	  {
        .           .          .                .          .          .                .            .          .           	    _M_set_node(_M_node - 1);
        .           .          .                .          .          .                .            .          .           	    _M_cur = _M_last;
        .           .          .                .          .          .                .            .          .           	  }
  869,532 ( 0.02%)  2 ( 0.03%) 2 ( 0.06%)       0          0          0          289,844 ( 0.07%)   0          0           	--_M_cur;
        .           .          .                .          .          .                .            .          .           	return *this;
        .           .          .                .          .          .                .            .          .                 }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Self
        .           .          .                .          .          .                .            .          .                 operator--(int) _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 {
        .           .          .                .          .          .                .            .          .           	_Self __tmp = *this;
        .           .          .                .          .          .                .            .          .           	--*this;
-- line 223 ----------------------------------------
-- line 254 ----------------------------------------
        .           .          .                .          .          .                .            .          .                 /**
        .           .          .                .          .          .                .            .          .                  *  Prepares to traverse new_node.  Sets everything except
        .           .          .                .          .          .                .            .          .                  *  _M_cur, which should therefore be set by the caller
        .           .          .                .          .          .                .            .          .                  *  immediately afterwards, based on _M_first and _M_last.
        .           .          .                .          .          .                .            .          .                  */
        .           .          .                .          .          .                .            .          .                 void
        .           .          .                .          .          .                .            .          .                 _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 {
    7,636 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)       0          0          0            7,636 ( 0.00%)   0          0           	_M_node = __new_node;
   30,532 ( 0.00%)  0          0           15,264 ( 0.00%) 0          0           15,268 ( 0.00%)   0          0           	_M_first = *__new_node;
   30,534 ( 0.00%)  0          0                0          0          0           15,268 ( 0.00%)   0          0           	_M_last = _M_first + difference_type(_S_buffer_size());
        .           .          .                .          .          .                .            .          .                 }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 friend bool
        .           .          .                .          .          .                .            .          .                 operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
   25,232 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)  18,550 ( 0.00%) 0          0                0            0          0                 { return __x._M_cur == __y._M_cur; }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 // Note: we also provide overloads whose operands are of the same type in
        .           .          .                .          .          .                .            .          .                 // order to avoid ambiguous overload resolution when std::rel_ops
        .           .          .                .          .          .                .            .          .                 // operators are in scope (for additional details, see libstdc++/3628)
        .           .          .                .          .          .                .            .          .                 template<typename _RefR, typename _PtrR>
        .           .          .                .          .          .                .            .          .           	friend bool
        .           .          .                .          .          .                .            .          .           	operator==(const _Self& __x,
        .           .          .                .          .          .                .            .          .           		   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
-- line 277 ----------------------------------------
-- line 348 ----------------------------------------
        .           .          .                .          .          .                .            .          .           	_GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .           	{ return !(__x < __y); }
        .           .          .                .          .          .                .            .          .           #endif // three-way comparison
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 friend difference_type
        .           .          .                .          .          .                .            .          .                 operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 {
        .           .          .                .          .          .                .            .          .           	return difference_type(_S_buffer_size())
2,075,612 ( 0.04%)  1 ( 0.02%) 1 ( 0.03%) 593,032 ( 0.05%) 0          0                0            0          0           	  * (__x._M_node - __y._M_node - bool(__x._M_node))
2,350,262 ( 0.04%)  1 ( 0.02%) 1 ( 0.03%) 867,682 ( 0.07%) 0          0          296,516 ( 0.07%)   0          0           	  + (__x._M_cur - __x._M_first)
2,613,979 ( 0.05%)  1 ( 0.02%) 1 ( 0.03%) 582,099 ( 0.05%) 0          0          571,166 ( 0.14%)   0          0           	  + (__y._M_last - __y._M_cur);
        .           .          .                .          .          .                .            .          .                 }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
        .           .          .                .          .          .                .            .          .                 // According to the resolution of DR179 not only the various comparison
        .           .          .                .          .          .                .            .          .                 // operators but also operator- must accept mixed iterator/const_iterator
        .           .          .                .          .          .                .            .          .                 // parameters.
        .           .          .                .          .          .                .            .          .                 template<typename _RefR, typename _PtrR>
        .           .          .                .          .          .                .            .          .           	friend difference_type
-- line 366 ----------------------------------------
-- line 431 ----------------------------------------
        .           .          .                .          .          .                .            .          .                 get_allocator() const _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .                 { return allocator_type(_M_get_Tp_allocator()); }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 typedef _Deque_iterator<_Tp, _Tp&, _Ptr>	  iterator;
        .           .          .                .          .          .                .            .          .                 typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_base()
        .           .          .                .          .          .                .            .          .                 : _M_impl()
   30,528 ( 0.00%)  0          0                0          0          0            7,632 ( 0.00%)   1 ( 0.00%) 0                 { _M_initialize_map(0); }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_base(size_t __num_elements)
        .           .          .                .          .          .                .            .          .                 : _M_impl()
        .           .          .                .          .          .                .            .          .                 { _M_initialize_map(__num_elements); }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_base(const allocator_type& __a, size_t __num_elements)
        .           .          .                .          .          .                .            .          .                 : _M_impl(__a)
        .           .          .                .          .          .                .            .          .                 { _M_initialize_map(__num_elements); }
-- line 447 ----------------------------------------
-- line 488 ----------------------------------------
        .           .          .                .          .          .                .            .          .                 struct _Deque_impl_data
        .           .          .                .          .          .                .            .          .                 {
        .           .          .                .          .          .                .            .          .           	_Map_pointer _M_map;
        .           .          .                .          .          .                .            .          .           	size_t _M_map_size;
        .           .          .                .          .          .                .            .          .           	iterator _M_start;
        .           .          .                .          .          .                .            .          .           	iterator _M_finish;
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .           	_Deque_impl_data() _GLIBCXX_NOEXCEPT
    7,632 ( 0.00%) 11 ( 0.19%) 1 ( 0.03%)       0          0          0            7,632 ( 0.00%)   0          0           	: _M_map(), _M_map_size(), _M_start(), _M_finish()
        .           .          .                .          .          .                .            .          .           	{ }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .           #if __cplusplus >= 201103L
        .           .          .                .          .          .                .            .          .           	_Deque_impl_data(const _Deque_impl_data&) = default;
        .           .          .                .          .          .                .            .          .           	_Deque_impl_data&
        .           .          .                .          .          .                .            .          .           	operator=(const _Deque_impl_data&) = default;
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .           	_Deque_impl_data(_Deque_impl_data&& __x) noexcept
-- line 504 ----------------------------------------
-- line 588 ----------------------------------------
        .           .          .                .          .          .                .            .          .                 void _M_destroy_nodes(_Map_pointer __nstart,
        .           .          .                .          .          .                .            .          .           			    _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT;
        .           .          .                .          .          .                .            .          .                 enum { _S_initial_map_size = 8 };
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 _Deque_impl _M_impl;
        .           .          .                .          .          .                .            .          .               };
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .             template<typename _Tp, typename _Alloc>
   38,170 ( 0.00%) 17 ( 0.30%) 1 ( 0.03%)       0          0          0           22,902 ( 0.01%)   0          0               _Deque_base<_Tp, _Alloc>::
        .           .          .                .          .          .                .            .          .               ~_Deque_base() _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .               {
   22,902 ( 0.00%)  0          0            7,634 ( 0.00%) 0          0                0            0          0                 if (this->_M_impl._M_map)
        .           .          .                .          .          .                .            .          .           	{
   22,902 ( 0.00%)  0          0           15,268 ( 0.00%) 0          0                0            0          0           	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
        .           .          .                .          .          .                .            .          .           			   this->_M_impl._M_finish._M_node + 1);
    7,634 ( 0.00%)  0          0            7,634 ( 0.00%) 0          0                0            0          0           	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
        .           .          .                .          .          .                .            .          .           	}
   22,902 ( 0.00%)  0          0           22,902 ( 0.00%) 0          0                0            0          0               }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .             /**
        .           .          .                .          .          .                .            .          .              *  @brief Layout storage.
        .           .          .                .          .          .                .            .          .              *  @param  __num_elements  The count of T's for which to allocate space
        .           .          .                .          .          .                .            .          .              *                          at first.
        .           .          .                .          .          .                .            .          .              *  @return   Nothing.
        .           .          .                .          .          .                .            .          .              *
        .           .          .                .          .          .                .            .          .              *  The initial underlying memory layout is a bit complicated...
        .           .          .                .          .          .                .            .          .             */
        .           .          .                .          .          .                .            .          .             template<typename _Tp, typename _Alloc>
        .           .          .                .          .          .                .            .          .               void
   61,056 ( 0.00%) 16 ( 0.28%) 1 ( 0.03%)       0          0          0           38,160 ( 0.01%)   1 ( 0.00%) 0               _Deque_base<_Tp, _Alloc>::
        .           .          .                .          .          .                .            .          .               _M_initialize_map(size_t __num_elements)
        .           .          .                .          .          .                .            .          .               {
   22,896 ( 0.00%)  0          0                0          0          0                0            0          0                 const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))
        .           .          .                .          .          .                .            .          .           				  + 1);
        .           .          .                .          .          .                .            .          .           
    7,634 ( 0.00%)  0          0                0          0          0            7,634 ( 0.00%)   0          0                 this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
    7,632 ( 0.00%)  0          0                0          0          0                0            0          0           					   size_t(__num_nodes + 2));
    7,634 ( 0.00%)  0          0                0          0          0            7,634 ( 0.00%)   0          0                 this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 // For "small" maps (needing less than _M_map_size nodes), allocation
        .           .          .                .          .          .                .            .          .                 // starts in the middle elements and grows outwards.  So nstart may be
        .           .          .                .          .          .                .            .          .                 // the beginning of _M_map, but for small maps it may be as far in as
        .           .          .                .          .          .                .            .          .                 // _M_map+3.
        .           .          .                .          .          .                .            .          .           
    7,634 ( 0.00%)  0          0                0          0          0                0            0          0                 _Map_pointer __nstart = (this->_M_impl._M_map
   22,896 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)   7,632 ( 0.00%) 0          0                0            0          0           			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
    7,632 ( 0.00%)  0          0                0          0          0                0            0          0                 _Map_pointer __nfinish = __nstart + __num_nodes;
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 __try
        .           .          .                .          .          .                .            .          .           	{ _M_create_nodes(__nstart, __nfinish); }
        .           .          .                .          .          .                .            .          .                 __catch(...)
        .           .          .                .          .          .                .            .          .           	{
        .           .          .                .          .          .                .            .          .           	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
        .           .          .                .          .          .                .            .          .           	  this->_M_impl._M_map = _Map_pointer();
        .           .          .                .          .          .                .            .          .           	  this->_M_impl._M_map_size = 0;
        .           .          .                .          .          .                .            .          .           	  __throw_exception_again;
        .           .          .                .          .          .                .            .          .           	}
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 this->_M_impl._M_start._M_set_node(__nstart);
   15,264 ( 0.00%)  0          0                0          0          0            7,632 ( 0.00%)   0          0                 this->_M_impl._M_finish._M_set_node(__nfinish - 1);
    7,634 ( 0.00%)  0          0                0          0          0            7,634 ( 0.00%)   0          0                 this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
        2 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)       0          0          0                2 ( 0.00%)   0          0                 this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
   15,264 ( 0.00%)  0          0                0          0          0            7,632 ( 0.00%)   0          0           					+ __num_elements
    7,632 ( 0.00%)  0          0                0          0          0                0            0          0           					% __deque_buf_size(sizeof(_Tp)));
   45,792 ( 0.00%)  0          0           45,792 ( 0.00%) 0          0                0            0          0               }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .             template<typename _Tp, typename _Alloc>
        .           .          .                .          .          .                .            .          .               void
        .           .          .                .          .          .                .            .          .               _Deque_base<_Tp, _Alloc>::
        .           .          .                .          .          .                .            .          .               _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
        .           .          .                .          .          .                .            .          .               {
        .           .          .                .          .          .                .            .          .                 _Map_pointer __cur;
        .           .          .                .          .          .                .            .          .                 __try
        .           .          .                .          .          .                .            .          .           	{
   53,424 ( 0.00%)  0          0                0          0          0                0            0          0           	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
    7,634 ( 0.00%)  0          0                0          0          0            7,634 ( 0.00%) 107 ( 0.01%) 0           	    *__cur = this->_M_allocate_node();
        .           .          .                .          .          .                .            .          .           	}
        .           .          .                .          .          .                .            .          .                 __catch(...)
        .           .          .                .          .          .                .            .          .           	{
        .           .          .                .          .          .                .            .          .           	  _M_destroy_nodes(__nstart, __cur);
        .           .          .                .          .          .                .            .          .           	  __throw_exception_again;
        .           .          .                .          .          .                .            .          .           	}
        .           .          .                .          .          .                .            .          .               }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .             template<typename _Tp, typename _Alloc>
        .           .          .                .          .          .                .            .          .               void
        .           .          .                .          .          .                .            .          .               _Deque_base<_Tp, _Alloc>::
        .           .          .                .          .          .                .            .          .               _M_destroy_nodes(_Map_pointer __nstart,
        .           .          .                .          .          .                .            .          .           		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
        .           .          .                .          .          .                .            .          .               {
   45,804 ( 0.00%)  0          0                0          0          0                0            0          0                 for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
        .           .          .                .          .          .                .            .          .           	_M_deallocate_node(*__n);
        .           .          .                .          .          .                .            .          .               }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .             /**
        .           .          .                .          .          .                .            .          .              *  @brief  A standard container using fixed-size memory allocation and
        .           .          .                .          .          .                .            .          .              *  constant-time manipulation of elements at either end.
        .           .          .                .          .          .                .            .          .              *
        .           .          .                .          .          .                .            .          .              *  @ingroup sequences
-- line 686 ----------------------------------------
-- line 999 ----------------------------------------
        .           .          .                .          .          .                .            .          .           #endif
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 /**
        .           .          .                .          .          .                .            .          .                  *  The dtor only erases the elements, and note that if the elements
        .           .          .                .          .          .                .            .          .                  *  themselves are pointers, the pointed-to memory is not touched in any
        .           .          .                .          .          .                .            .          .                  *  way.  Managing the pointer is the user's responsibility.
        .           .          .                .          .          .                .            .          .                  */
        .           .          .                .          .          .                .            .          .                 ~deque()
   15,268 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)       0          0          0            7,634 ( 0.00%)   0          0                 { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 /**
        .           .          .                .          .          .                .            .          .                  *  @brief  %Deque assignment operator.
        .           .          .                .          .          .                .            .          .                  *  @param  __x  A %deque of identical element and allocator types.
        .           .          .                .          .          .                .            .          .                  *
        .           .          .                .          .          .                .            .          .                  *  All the elements of @a x are copied.
        .           .          .                .          .          .                .            .          .                  *
        .           .          .                .          .          .                .            .          .                  *  The newly-created %deque uses a copy of the allocator object used
-- line 1015 ----------------------------------------
-- line 1504 ----------------------------------------
        .           .          .                .          .          .                .            .          .           	  }
        .           .          .                .          .          .                .            .          .           	else
        .           .          .                .          .          .                .            .          .           	  _M_push_back_aux(__x);
        .           .          .                .          .          .                .            .          .                 }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .           #if __cplusplus >= 201103L
        .           .          .                .          .          .                .            .          .                 void
        .           .          .                .          .          .                .            .          .                 push_back(value_type&& __x)
1,590,219 ( 0.03%)  2 ( 0.03%) 1 ( 0.03%)       0          0          0          494,277 ( 0.12%)   0          0                 { emplace_back(std::move(__x)); }
        .           .          .                .          .          .                .            .          .           
        .           .          .                .          .          .                .            .          .                 template<typename... _Args>
        .           .          .                .          .          .                .            .          .           #if __cplusplus > 201402L
        .           .          .                .          .          .                .            .          .           	reference
        .           .          .                .          .          .                .            .          .           #else
        .           .          .                .          .          .                .            .          .           	void
        .           .          .                .          .          .                .            .          .           #endif
        .           .          .                .          .          .                .            .          .           	emplace_back(_Args&&... __args);
-- line 1520 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/unique_ptr.h
--------------------------------------------------------------------------------
Ir                   I1mr        ILmr       Dr                   D1mr           DLmr       Dw                 D1mw       DLmw       

-- line 112 ----------------------------------------
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 /// Calls `delete[] __ptr`
          .           .          .                    .              .          .                  .          .          .                 template<typename _Up>
          .           .          .                    .              .          .                  .          .          .           	typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
          .           .          .                    .              .          .                  .          .          .           	operator()(_Up* __ptr) const
          .           .          .                    .              .          .                  .          .          .           	{
          .           .          .                    .              .          .                  .          .          .           	  static_assert(sizeof(_Tp)>0,
          .           .          .                    .              .          .                  .          .          .           			"can't delete pointer to incomplete type");
     26,692 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)         718 ( 0.00%)     0          0             15,528 ( 0.00%) 0          0           	  delete [] __ptr;
          .           .          .                    .              .          .                  .          .          .           	}
          .           .          .                    .              .          .                  .          .          .               };
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .             /// @cond undocumented
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .             // Manages the pointer and deleter of a unique_ptr
          .           .          .                    .              .          .                  .          .          .             template <typename _Tp, typename _Dp>
          .           .          .                    .              .          .                  .          .          .               class __uniq_ptr_impl
-- line 128 ----------------------------------------
-- line 165 ----------------------------------------
          .           .          .                    .              .          .                  .          .          .                 __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
          .           .          .                    .              .          .                  .          .          .                 {
          .           .          .                    .              .          .                  .          .          .           	reset(__u.release());
          .           .          .                    .              .          .                  .          .          .           	_M_deleter() = std::forward<_Dp>(__u._M_deleter());
          .           .          .                    .              .          .                  .          .          .           	return *this;
          .           .          .                    .              .          .                  .          .          .                 }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 pointer&   _M_ptr() { return std::get<0>(_M_t); }
     53,857 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)      53,768 ( 0.00%)     0          0                  0          0          0                 pointer    _M_ptr() const { return std::get<0>(_M_t); }
          .           .          .                    .              .          .                  .          .          .                 _Dp&       _M_deleter() { return std::get<1>(_M_t); }
          .           .          .                    .              .          .                  .          .          .                 const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 void reset(pointer __p) noexcept
          .           .          .                    .              .          .                  .          .          .                 {
     26,554 ( 0.00%)  0          0               26,554 ( 0.00%)     0          0                  0          0          0           	const pointer __old_p = _M_ptr();
     25,615 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%)           0              0          0             25,615 ( 0.01%) 0          0           	_M_ptr() = __p;
     51,230 ( 0.00%)  0          0                    0              0          0                  0          0          0           	if (__old_p)
          .           .          .                    .              .          .                  .          .          .           	  _M_deleter()(__old_p);
          .           .          .                    .              .          .                  .          .          .                 }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 pointer release() noexcept
          .           .          .                    .              .          .                  .          .          .                 {
          .           .          .                    .              .          .                  .          .          .           	pointer __p = _M_ptr();
          .           .          .                    .              .          .                  .          .          .           	_M_ptr() = nullptr;
          .           .          .                    .              .          .                  .          .          .           	return __p;
-- line 189 ----------------------------------------
-- line 603 ----------------------------------------
          .           .          .                    .              .          .                  .          .          .           	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
          .           .          .                    .              .          .                  .          .          .           	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
          .           .          .                    .              .          .                  .          .          .           	{ }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 /// Destructor, invokes the deleter if the stored pointer is not null.
          .           .          .                    .              .          .                  .          .          .                 ~unique_ptr()
          .           .          .                    .              .          .                  .          .          .                 {
          .           .          .                    .              .          .                  .          .          .           	auto& __ptr = _M_t._M_ptr();
     30,261 ( 0.00%)  0          0               10,087 ( 0.00%) 4,862 ( 0.55%) 0                  0          0          0           	if (__ptr != nullptr)
          .           .          .                    .              .          .                  .          .          .           	  get_deleter()(__ptr);
          .           .          .                    .              .          .                  .          .          .           	__ptr = pointer();
          .           .          .                    .              .          .                  .          .          .                 }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 // Assignment.
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 /** @brief Move assignment operator.
          .           .          .                    .              .          .                  .          .          .                  *
-- line 619 ----------------------------------------
-- line 652 ----------------------------------------
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 // Observers.
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 /// Access an element of owned array.
          .           .          .                    .              .          .                  .          .          .                 typename std::add_lvalue_reference<element_type>::type
          .           .          .                    .              .          .                  .          .          .                 operator[](size_t __i) const
          .           .          .                    .              .          .                  .          .          .                 {
          .           .          .                    .              .          .                  .          .          .           	__glibcxx_assert(get() != pointer());
225,536,139 ( 4.12%)  9 ( 0.16%) 5 ( 0.14%) 112,768,207 ( 8.98%)    18 ( 0.00%) 0                  0          0          0           	return get()[__i];
          .           .          .                    .              .          .                  .          .          .                 }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 /// Return the stored pointer.
          .           .          .                    .              .          .                  .          .          .                 pointer
          .           .          .                    .              .          .                  .          .          .                 get() const noexcept
          .           .          .                    .              .          .                  .          .          .                 { return _M_t._M_ptr(); }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .                 /// Return a reference to the stored deleter.
-- line 668 ----------------------------------------
-- line 960 ----------------------------------------
          .           .          .                    .              .          .                  .          .          .               inline typename _MakeUniq<_Tp>::__single_object
          .           .          .                    .              .          .                  .          .          .               make_unique(_Args&&... __args)
          .           .          .                    .              .          .                  .          .          .               { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .             /// std::make_unique for arrays of unknown bound
          .           .          .                    .              .          .                  .          .          .             template<typename _Tp>
          .           .          .                    .              .          .                  .          .          .               inline typename _MakeUniq<_Tp>::__array
          .           .          .                    .              .          .                  .          .          .               make_unique(size_t __num)
  6,001,074 ( 0.11%) 34 ( 0.59%) 5 ( 0.14%)           0              0          0          1,036,637 ( 0.25%) 0          0               { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .             /// Disable std::make_unique for arrays of known bound
          .           .          .                    .              .          .                  .          .          .             template<typename _Tp, typename... _Args>
          .           .          .                    .              .          .                  .          .          .               typename _MakeUniq<_Tp>::__invalid_type
          .           .          .                    .              .          .                  .          .          .               make_unique(_Args&&...) = delete;
          .           .          .                    .              .          .                  .          .          .           
          .           .          .                    .              .          .                  .          .          .           #if __cplusplus > 201703L
          .           .          .                    .              .          .                  .          .          .             /// std::make_unique_for_overwrite for single objects
-- line 976 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dhruvs6/598APE-HW2/src/node_detail.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                   D1mr            DLmr       Dw                   D1mw        DLmw       

-- line 7 ----------------------------------------
          .          .          .                    .               .          .                    .           .          .           #include <cstdlib>
          .          .          .                    .               .          .                    .           .          .           
          .          .          .                    .               .          .                    .           .          .           namespace genetic {
          .          .          .                    .               .          .                    .           .          .               namespace detail {
          .          .          .                    .               .          .                    .           .          .           
          .          .          .                    .               .          .                    .           .          .                   static constexpr float MIN_VAL = 0.001f;
          .          .          .                    .               .          .                    .           .          .           
          .          .          .                    .               .          .                    .           .          .                   inline bool is_terminal(node::type t) {
        550 ( 0.00%) 0          0                  275 ( 0.00%)     16 ( 0.00%) 0                    0           0          0                       return t == node::type::variable || t == node::type::constant;
          .          .          .                    .               .          .                    .           .          .                   }
          .          .          .                    .               .          .                    .           .          .           
          .          .          .                    .               .          .                    .           .          .                   inline bool is_nonterminal(node::type t) {
  1,880,894 ( 0.03%) 0          0              940,447 ( 0.07%) 96,462 (10.83%) 0                    0           0          0                       return !is_terminal(t);
          .          .          .                    .               .          .                    .           .          .                   }
          .          .          .                    .               .          .                    .           .          .           
          .          .          .                    .               .          .                    .           .          .                   inline int arity(node::type t) {
    861,095 ( 0.02%) 0          0                    0               0          0                    0           0          0                       if (node::type::unary_begin <= t && t <= node::type::unary_end) {
    276,785 ( 0.01%) 0          0                    0               0          0                    0           0          0                           return 1;
          .          .          .                    .               .          .                    .           .          .                       }
    581,469 ( 0.01%) 1 ( 0.02%) 0                    0               0          0                    0           0          0                       if (node::type::binary_begin <= t && t <= node::type::binary_end) {
          .          .          .                    .               .          .                    .           .          .                           return 2;
          .          .          .                    .               .          .                    .           .          .                       }
          .          .          .                    .               .          .                    .           .          .                       return 0;
          .          .          .                    .               .          .                    .           .          .                   }
          .          .          .                    .               .          .                    .           .          .           
          .          .          .                    .               .          .                    .           .          .                   inline float evaluate_node_lookup(const node& n, const float* data, const uint64_t stride,
          .          .          .                    .               .          .                    .           .          .                                                     const uint64_t idx, const float in1, const float in2) {
112,192,694 ( 2.05%) 0          0          112,192,694 ( 8.94%) 38,904 ( 4.37%) 0                    0           0          0                       const auto& func = function_table[static_cast<size_t>(n.t)];
224,385,388 ( 4.10%) 0          0                    0               0          0                    0           0          0                       if (n.t == node::type::constant) {
  5,756,212 ( 0.11%) 1 ( 0.02%) 1 ( 0.03%)   2,878,106 ( 0.23%)      0          0                    0           0          0                           return n.u.val;
218,629,176 ( 3.99%) 0          0                    0               0          0                    0           0          0                       } else if (n.t == node::type::variable) {
193,170,768 ( 3.53%) 1 ( 0.02%) 1 ( 0.03%) 128,780,512 (10.26%) 16,228 ( 1.82%) 0                    0           0          0                           return data[(stride * n.u.fid) + idx];
          .          .          .                    .               .          .                    .           .          .                       } else {
539,836,220 ( 9.86%) 0          0          231,358,380 (18.43%)     71 ( 0.01%) 0          231,358,380 (56.24%) 11 ( 0.00%) 0                           return func(in1, in2);
          .          .          .                    .               .          .                    .           .          .                       }
          .          .          .                    .               .          .                    .           .          .                   }
          .          .          .                    .               .          .                    .           .          .           
          .          .          .                    .               .          .                    .           .          .                   // `data` assumed to be stored in col-major format
          .          .          .                    .               .          .                    .           .          .                   inline float evaluate_node(const node& n, const float* data, const uint64_t stride,
          .          .          .                    .               .          .                    .           .          .                                              const uint64_t idx, const float* in) {
          .          .          .                    .               .          .                    .           .          .                       if (n.t == node::type::constant) {
          .          .          .                    .               .          .                    .           .          .                           return n.u.val;
-- line 48 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/std_abs.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr        DLmr       Dw         D1mw       DLmw       

-- line 68 ----------------------------------------
         .          .          .                   .           .          .          .          .          .           
         .          .          .                   .           .          .          .          .          .           #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
         .          .          .                   .           .          .          .          .          .             inline _GLIBCXX_CONSTEXPR double
         .          .          .                   .           .          .          .          .          .             abs(double __x)
         .          .          .                   .           .          .          .          .          .             { return __builtin_fabs(__x); }
         .          .          .                   .           .          .          .          .          .           
         .          .          .                   .           .          .          .          .          .             inline _GLIBCXX_CONSTEXPR float
         .          .          .                   .           .          .          .          .          .             abs(float __x)
11,574,196 ( 0.21%) 0          0          11,574,196 ( 0.92%) 17 ( 0.00%) 0          0          0          0             { return __builtin_fabsf(__x); }
         .          .          .                   .           .          .          .          .          .           
         .          .          .                   .           .          .          .          .          .             inline _GLIBCXX_CONSTEXPR long double
         .          .          .                   .           .          .          .          .          .             abs(long double __x)
         .          .          .                   .           .          .          .          .          .             { return __builtin_fabsl(__x); }
         .          .          .                   .           .          .          .          .          .           #endif
         .          .          .                   .           .          .          .          .          .           
         .          .          .                   .           .          .          .          .          .           #if defined(__GLIBCXX_TYPE_INT_N_0)
         .          .          .                   .           .          .          .          .          .             inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
-- line 84 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dhruvs6/598APE-HW2/src/philox_rng.cpp
--------------------------------------------------------------------------------
Ir                 I1mr        ILmr       Dr               D1mr        DLmr       Dw               D1mw        DLmw       

-- line 3 ----------------------------------------
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Global generator state */
        .           .          .                .           .          .                .           .          .           static philox_state_t global_philox_state = {
        .           .          .                .           .          .                .           .          .               .counter = {1, 2, 3, 3}, .key = {56, 712}, .initialized = false};
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Helper function to return the lower and higher 32-bits from two 32-bit
        .           .          .                .           .          .                .           .          .            * integer multiplications. */
        .           .          .                .           .          .                .           .          .           static void multiply_high_low(uint32_t a, uint32_t b, uint32_t* result_low, uint32_t* result_high) {
6,517,502 ( 0.12%)  1 ( 0.02%) 1 ( 0.03%)       0           0          0                0           0          0               uint64_t product = (uint64_t)a * b;
2,102,420 ( 0.04%)  0          0                0           0          0                0           0          0               *result_low      = (uint32_t)product;
4,204,840 ( 0.08%)  2 ( 0.03%) 1 ( 0.03%)       0           0          0                0           0          0               *result_high     = (uint32_t)(product >> 32);
        .           .          .                .           .          .                .           .          .           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Helper function for a single round of the underlying Philox algorithm. */
        .           .          .                .           .          .                .           .          .           static void philox_oneround(uint32_t counter[4], uint32_t key[2]) {
        .           .          .                .           .          .                .           .          .               uint32_t lo0, hi0, lo1, hi1;
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .               multiply_high_low(PHILOX_M4x32A, counter[0], &lo0, &hi0);
        .           .          .                .           .          .                .           .          .               multiply_high_low(PHILOX_M4x32B, counter[2], &lo1, &hi1);
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .               uint32_t result[4];
2,102,420 ( 0.04%)  0          0                0           0          0                0           0          0               result[0] = hi1 ^ counter[1] ^ key[0];
        .           .          .                .           .          .                .           .          .               result[1] = lo1;
2,102,420 ( 0.04%)  0          0                0           0          0                0           0          0               result[2] = hi0 ^ counter[3] ^ key[1];
        .           .          .                .           .          .                .           .          .               result[3] = lo0;
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .               counter[0] = result[0];
        .           .          .                .           .          .                .           .          .               counter[1] = result[1];
        .           .          .                .           .          .                .           .          .               counter[2] = result[2];
        .           .          .                .           .          .                .           .          .               counter[3] = result[3];
        .           .          .                .           .          .                .           .          .           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           static void philox_raisekey(uint32_t key[2]) {
        .           .          .                .           .          .                .           .          .               key[0] += PHILOX_W32A;
        .           .          .                .           .          .                .           .          .               key[1] += PHILOX_W32B;
        .           .          .                .           .          .                .           .          .           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Seed the RNG with a single value */
       32 ( 0.00%) 13 ( 0.23%) 1 ( 0.03%)       0           0          0                0           0          0           void philox_seed(uint32_t seed) {
       32 ( 0.00%)  0          0                0           0          0               32 ( 0.00%)  1 ( 0.00%) 0               global_philox_state.counter[0]  = seed;
       32 ( 0.00%)  0          0                0           0          0               32 ( 0.00%)  0          0               global_philox_state.counter[1]  = 2;
       64 ( 0.00%)  0          0                0           0          0               32 ( 0.00%)  0          0               global_philox_state.counter[2]  = 3;
        .           .          .                .           .          .                .           .          .               global_philox_state.counter[3]  = 4;
       64 ( 0.00%)  0          0                0           0          0               32 ( 0.00%)  0          0               global_philox_state.key[0]      = PHILOX_W32A;
        .           .          .                .           .          .                .           .          .               global_philox_state.key[1]      = PHILOX_W32B;
       32 ( 0.00%)  0          0                0           0          0               32 ( 0.00%)  0          0               global_philox_state.initialized = true;
       32 ( 0.00%)  0          0               32 ( 0.00%)  0          0                0           0          0           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Seed the RNG with a value and custom keys */
        .           .          .                .           .          .                .           .          .           void philox_seed_with_key(uint32_t seed, uint32_t key0, uint32_t key1) {
        .           .          .                .           .          .                .           .          .               global_philox_state.counter[0]  = seed;
        .           .          .                .           .          .                .           .          .               global_philox_state.counter[1]  = 2;
        .           .          .                .           .          .                .           .          .               global_philox_state.counter[2]  = 3;
        .           .          .                .           .          .                .           .          .               global_philox_state.counter[3]  = 4;
        .           .          .                .           .          .                .           .          .               global_philox_state.key[0]      = key0;
-- line 57 ----------------------------------------
-- line 66 ----------------------------------------
        .           .          .                .           .          .                .           .          .               global_philox_state.counter[2]  = 3;
        .           .          .                .           .          .                .           .          .               global_philox_state.counter[3]  = 3;
        .           .          .                .           .          .                .           .          .               global_philox_state.key[0]      = 56;
        .           .          .                .           .          .                .           .          .               global_philox_state.key[1]      = 712;
        .           .          .                .           .          .                .           .          .               global_philox_state.initialized = true;
        .           .          .                .           .          .                .           .          .           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Skip the specified number of samples of 128-bits in the current stream. */
  105,121 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%)       0           0          0                0           0          0           void philox_skip(uint64_t count) {
  210,242 ( 0.00%)  0          0          105,121 ( 0.01%)  0          0                0           0          0               if (!global_philox_state.initialized) {
        .           .          .                .           .          .                .           .          .                   philox_reset();
        .           .          .                .           .          .                .           .          .               }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .               const uint32_t count_lo = (uint32_t)count;
  210,242 ( 0.00%)  0          0                0           0          0                0           0          0               uint32_t       count_hi = (uint32_t)(count >> 32);
        .           .          .                .           .          .                .           .          .           
  420,484 ( 0.01%)  0          0          105,121 ( 0.01%)  0          0          105,121 ( 0.03%)  0          0               global_philox_state.counter[0] += count_lo;
  105,121 ( 0.00%)  0          0                0           0          0                0           0          0               if (global_philox_state.counter[0] < count_lo) {
  210,242 ( 0.00%)  0          0                0           0          0                0           0          0                   ++count_hi;
        .           .          .                .           .          .                .           .          .               }
        .           .          .                .           .          .                .           .          .           
  315,363 ( 0.01%)  0          0          105,121 ( 0.01%)  0          0          105,121 ( 0.03%)  0          0               global_philox_state.counter[1] += count_hi;
  105,121 ( 0.00%)  0          0                0           0          0                0           0          0               if (global_philox_state.counter[1] < count_hi) {
        .           .          .                .           .          .                .           .          .                   if (++global_philox_state.counter[2] == 0) {
        .           .          .                .           .          .                .           .          .                       ++global_philox_state.counter[3];
        .           .          .                .           .          .                .           .          .                   }
        .           .          .                .           .          .                .           .          .               }
  105,121 ( 0.00%)  1 ( 0.02%) 1 ( 0.03%) 105,121 ( 0.01%)  0          0                0           0          0           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Returns a group of four random numbers using the underlying Philox algorithm. */
  735,847 ( 0.01%)  1 ( 0.02%) 1 ( 0.03%)       0           0          0          525,605 ( 0.13%) 14 ( 0.00%) 0           void philox_next4(uint32_t out[4]) {
  210,242 ( 0.00%)  0          0          105,121 ( 0.01%) 16 ( 0.00%) 0                0           0          0               if (!global_philox_state.initialized) {
        .           .          .                .           .          .                .           .          .                   philox_reset();
        .           .          .                .           .          .                .           .          .               }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .               for (int i = 0; i < 4; i++) {
  946,089 ( 0.02%)  1 ( 0.02%) 1 ( 0.03%) 420,484 ( 0.03%)  0          0          315,363 ( 0.08%)  0          0                   out[i] = global_philox_state.counter[i];
        .           .          .                .           .          .                .           .          .               }
        .           .          .                .           .          .                .           .          .           
  210,242 ( 0.00%)  0          0          210,242 ( 0.02%)  0          0                0           0          0               uint32_t key[2] = {global_philox_state.key[0], global_philox_state.key[1]};
        .           .          .                .           .          .                .           .          .           
3,889,477 ( 0.07%)  0          0                0           0          0                0           0          0               for (int i = 0; i < 10; i++) {
        .           .          .                .           .          .                .           .          .                   philox_oneround(out, key);
2,207,541 ( 0.04%)  0          0                0           0          0          105,121 ( 0.03%)  0          0                   if (i == 9) {
  315,363 ( 0.01%)  0          0                0           0          0          105,121 ( 0.03%)  0          0                       philox_skip(1);
        .           .          .                .           .          .                .           .          .                   } else {
        .           .          .                .           .          .                .           .          .                       philox_raisekey(key);
        .           .          .                .           .          .                .           .          .                   }
        .           .          .                .           .          .                .           .          .               }
  735,847 ( 0.01%)  0          0          525,605 ( 0.04%)  0          0          210,242 ( 0.05%)  0          0           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Generate a random 32-bit unsigned integer */
  525,605 ( 0.01%)  2 ( 0.03%) 1 ( 0.03%) 105,121 ( 0.01%)  0          0          105,121 ( 0.03%)  0          0           uint32_t philox_random_uint32(void) {
        .           .          .                .           .          .                .           .          .               uint32_t out[4];
  210,242 ( 0.00%)  0          0                0           0          0          105,121 ( 0.03%)  0          0               philox_next4(out);
  105,121 ( 0.00%)  2 ( 0.03%) 1 ( 0.03%) 105,121 ( 0.01%)  0          0                0           0          0               return out[0];
  525,605 ( 0.01%)  0          0          315,363 ( 0.03%)  0          0                0           0          0           }
        .           .          .                .           .          .                .           .          .           
        .           .          .                .           .          .                .           .          .           /* Generate a random 64-bit unsigned integer */
        .           .          .                .           .          .                .           .          .           uint64_t philox_random_uint64(void) {
        .           .          .                .           .          .                .           .          .               uint32_t out[4];
        .           .          .                .           .          .                .           .          .               philox_next4(out);
        .           .          .                .           .          .                .           .          .               return ((uint64_t)out[0] << 32) | out[1];
        .           .          .                .           .          .                .           .          .           }
        .           .          .                .           .          .                .           .          .           
-- line 130 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dhruvs6/598APE-HW2/src/../include/evaluate.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr       DLmr       Dw         D1mw       DLmw       

-- line 16 ----------------------------------------
         .          .          .                   .          .          .          .          .          .           */
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           static constexpr float EPSILON = 0.001f;
         .          .          .                   .          .          .          .          .          .           
         .          .          .                   .          .          .          .          .          .           static const FnPtr function_table[] = {
         .          .          .                   .          .          .          .          .          .               // Skip variable (0) and constant (1)
         .          .          .                   .          .          .          .          .          .               nullptr, nullptr,
         .          .          .                   .          .          .          .          .          .               // Binary functions
35,670,966 ( 0.65%) 6 ( 0.10%) 1 ( 0.03%) 11,890,322 ( 0.95%) 0          0          0          0          0               [](float a, float b) { return a + b; },                                // add
         .          .          .                   .          .          .          .          .          .               [](float a, float b) { return std::atan2(a, b); },                     // atan2
         .          .          .                   .          .          .          .          .          .               [](float a, float b) { return std::abs(b) < EPSILON ? 1.0f : a / b; }, // div
 8,467,584 ( 0.15%) 0          0                   0          0          0          0          0          0               [](float a, float b) { return std::fdim(a, b); },                      // fdim
         .          .          .                   .          .          .          .          .          .               [](float a, float b) { return std::max(a, b); },                       // max
         .          .          .                   .          .          .          .          .          .               [](float a, float b) { return std::min(a, b); },                       // min
22,630,938 ( 0.41%) 0          0           7,543,646 ( 0.60%) 0          0          0          0          0               [](float a, float b) { return a * b; },                                // mul
         .          .          .                   .          .          .          .          .          .               [](float a, float b) { return std::pow(a, b); },                       // pow
12,814,614 ( 0.23%) 1 ( 0.02%) 1 ( 0.03%)  4,271,538 ( 0.34%) 0          0          0          0          0               [](float a, float b) { return a - b; },                                // sub
         .          .          .                   .          .          .          .          .          .               // Unary functions
14,326,720 ( 0.26%) 2 ( 0.03%) 1 ( 0.03%)  7,163,360 ( 0.57%) 0          0          0          0          0               [](float a, float) { return std::abs(a); },                           // abs
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::acos(a); },                          // acos
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::acosh(a); },                         // acosh
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::asin(a); },                          // asin
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::asinh(a); },                         // asinh
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::atan(a); },                          // atan
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::atanh(a); },                         // atanh
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::cbrt(a); },                          // cbrt
 8,667,328 ( 0.16%) 1 ( 0.02%) 1 ( 0.03%)          0          0          0          0          0          0               [](float a, float) { return std::cos(a); },                           // cos
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::cosh(a); },                          // cosh
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return a * a * a; },                             // cube
19,679,996 ( 0.36%) 1 ( 0.02%) 1 ( 0.03%)          0          0          0          0          0          0               [](float a, float) { return std::exp(a); },                           // exp
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::abs(a) < EPSILON ? 0.f : 1.f / a; }, // inv
 4,410,836 ( 0.08%) 1 ( 0.02%) 1 ( 0.03%)          0          0          0          0          0          0               [](float a, float) {
         .          .          .                   .          .          .          .          .          .                   float abs_a = std::abs(a);
13,232,508 ( 0.24%) 0          0           4,410,836 ( 0.35%) 0          0          0          0          0                   return abs_a < EPSILON ? 0.f : std::log(abs_a);
 1,544,368 ( 0.03%) 0          0             772,184 ( 0.06%) 0          0          0          0          0               },                                                            // log
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return -a; },                            // neg
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return 1.0f / std::cbrt(a); },           // rcbrt
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return 1.0f / std::sqrt(std::abs(a)); }, // rsqrt
 5,024,850 ( 0.09%) 1 ( 0.02%) 1 ( 0.03%)          0          0          0          0          0          0               [](float a, float) { return std::sin(a); },                   // sin
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::sinh(a); },                  // sinh
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return a * a; },                         // sq
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::sqrt(std::abs(a)); },        // sqrt
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::tan(a); },                   // tan
         .          .          .                   .          .          .          .          .          .               [](float a, float) { return std::tanh(a); },                  // tanh
         .          .          .                   .          .          .          .          .          .           };
--------------------------------------------------------------------------------
-- Auto-annotated source: /home/dhruvs6/598APE-HW2/src/node.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr             DLmr         Dw                 D1mw            DLmw         

-- line 25 ----------------------------------------
        .          .          .                  .                .            .                  .               .            .                   if (!(check))                                                                              \
        .          .          .                  .                .            .                  .               .            .                       THROW(fmt, ##__VA_ARGS__);                                                             \
        .          .          .                  .                .            .                  .               .            .               } while (0)
        .          .          .                  .                .            .                  .               .            .           
        .          .          .                  .                .            .                  .               .            .           namespace genetic {
        .          .          .                  .                .            .                  .               .            .           
        .          .          .                  .                .            .                  .               .            .               const int node::kInvalidFeatureId = -1;
        .          .          .                  .                .            .                  .               .            .           
1,124,685 ( 0.02%) 1 ( 0.02%) 1 ( 0.03%)         0                0            0                  0               0            0               node::node() {
1,124,685 ( 0.02%) 0          0          1,124,685 ( 0.09%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
   76,850 ( 0.00%) 2 ( 0.03%) 1 ( 0.03%)     7,685 ( 0.00%)       0            0             46,110 ( 0.01%)      0            0               node::node(node::type ft) : t(ft) {
   15,370 ( 0.00%) 0          0                  0                0            0                  0               0            0                   ASSERT(is_nonterminal(), "node: ctor with `type` argument expects functions type only!");
    7,685 ( 0.00%) 0          0                  0                0            0              7,685 ( 0.00%)      0            0                   u.fid              = kInvalidFeatureId;
   34,171 ( 0.00%) 1 ( 0.02%) 1 ( 0.03%)     7,685 ( 0.00%)       0            0              7,685 ( 0.00%)      0            0                   flags.arity_       = detail::arity(ft);
        .          .          .                  .                .            .                  .               .            .                   flags.is_terminal_ = detail::is_terminal(ft);
   69,165 ( 0.00%) 0          0             53,795 ( 0.00%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
    7,858 ( 0.00%) 2 ( 0.03%) 1 ( 0.03%)         0                0            0              3,929 ( 0.00%)      0            0               node::node(int fid) : t(node::type::variable) {
    3,929 ( 0.00%) 0          0                  0                0            0              3,929 ( 0.00%)      0            0                   u.fid              = fid;
   15,716 ( 0.00%) 0          0              3,929 ( 0.00%)       0            0              3,929 ( 0.00%)      0            0                   flags.arity_       = detail::arity(t);
        .          .          .                  .                .            .                  .               .            .                   flags.is_terminal_ = detail::is_terminal(t);
    3,929 ( 0.00%) 0          0              3,929 ( 0.00%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
      752 ( 0.00%) 0          0                  0                0            0                376 ( 0.00%)      0            0               node::node(float val) : t(node::type::constant) {
      376 ( 0.00%) 0          0                  0                0            0                376 ( 0.00%)      0            0                   u.val              = val;
    1,504 ( 0.00%) 0          0                376 ( 0.00%)       0            0                376 ( 0.00%)      0            0                   flags.arity_       = detail::arity(t);
        .          .          .                  .                .            .                  .               .            .                   flags.is_terminal_ = detail::is_terminal(t);
      376 ( 0.00%) 0          0                376 ( 0.00%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
1,505,030 ( 0.03%) 1 ( 0.02%) 1 ( 0.03%)   602,012 ( 0.05%)       0            0            602,012 ( 0.15%)    496 ( 0.06%)  17 ( 0.02%)      node::node(const node& src) : t(src.t), u(src.u) {
1,806,036 ( 0.03%) 1 ( 0.02%) 1 ( 0.03%)   602,012 ( 0.05%)     140 ( 0.02%)   8 ( 0.09%)   301,006 ( 0.07%)      0            0                   flags.arity_       = src.flags.arity_;
        .          .          .                  .                .            .                  .               .            .                   flags.is_terminal_ = src.flags.is_terminal_;
  301,006 ( 0.01%) 0          0            301,006 ( 0.02%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
2,271,980 ( 0.04%) 0          0                  0                0            0                  0               0            0               node& node::operator=(const node& src) {
2,271,980 ( 0.04%) 0          0          1,135,990 ( 0.09%)  56,185 ( 6.31%)   0          1,135,990 ( 0.28%) 54,195 ( 6.04%) 428 ( 0.42%)          t                  = src.t;
2,271,980 ( 0.04%) 0          0          1,135,990 ( 0.09%)       0            0          1,135,990 ( 0.28%) 55,643 ( 6.21%) 372 ( 0.37%)          u                  = src.u;
6,815,940 ( 0.12%) 1 ( 0.02%) 1 ( 0.03%) 2,271,980 ( 0.18%) 145,655 (16.36%) 465 ( 5.16%) 1,135,990 ( 0.28%)      0            0                   flags.arity_       = src.flags.arity_;
5,679,950 ( 0.10%) 0          0          1,135,990 ( 0.09%)       0            0          1,135,990 ( 0.28%)      0            0                   flags.is_terminal_ = src.flags.is_terminal_;
        .          .          .                  .                .            .                  .               .            .                   return *this;
1,135,990 ( 0.02%) 0          0          1,135,990 ( 0.09%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
      275 ( 0.00%) 1 ( 0.02%) 0                  0                0            0                  0               0            0               bool node::is_terminal() const {
        .          .          .                  .                .            .                  .               .            .                   return detail::is_terminal(t);
      275 ( 0.00%) 0          0                275 ( 0.00%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
  940,447 ( 0.02%) 0          0                  0                0            0                  0               0            0               bool node::is_nonterminal() const {
        .          .          .                  .                .            .                  .               .            .                   return detail::is_nonterminal(t);
  940,447 ( 0.02%) 0          0            940,447 ( 0.07%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
  276,785 ( 0.01%) 2 ( 0.03%) 1 ( 0.03%)         0                0            0                  0               0            0               int node::arity() const {
  276,785 ( 0.01%) 0          0            276,785 ( 0.02%)       0            0                  0               0            0                   return detail::arity(t);
  276,785 ( 0.01%) 0          0            276,785 ( 0.02%)       0            0                  0               0            0               }
        .          .          .                  .                .            .                  .               .            .           
        .          .          .                  .                .            .                  .               .            .           #define CASE(str, val)                                                                             \
        .          .          .                  .                .            .                  .               .            .               if (#val == str)                                                                               \
        .          .          .                  .                .            .                  .               .            .               return node::type::val
        .          .          .                  .                .            .                  .               .            .           
        .          .          .                  .                .            .                  .               .            .               node::type node::from_str(const std::string& ntype) {
        .          .          .                  .                .            .                  .               .            .                   CASE(ntype, variable);
        .          .          .                  .                .            .                  .               .            .                   CASE(ntype, constant);
-- line 86 ----------------------------------------
-- line 119 ----------------------------------------
        .          .          .                  .                .            .                  .               .            .                   CASE(ntype, sin);
        .          .          .                  .                .            .                  .               .            .                   CASE(ntype, sinh);
        .          .          .                  .                .            .                  .               .            .                   CASE(ntype, tan);
        .          .          .                  .                .            .                  .               .            .                   CASE(ntype, tanh);
        .          .          .                  .                .            .                  .               .            .                   ASSERT(false, "node::from_str: Bad type passed '%s'!", ntype.c_str());
        .          .          .                  .                .            .                  .               .            .               }
        .          .          .                  .                .            .                  .               .            .           #undef CASE
        .          .          .                  .                .            .                  .               .            .           
        3 ( 0.00%) 0          0                  1 ( 0.00%)       0            0                  1 ( 0.00%)      0            0           } // namespace genetic

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./math/../sysdeps/ieee754/flt-32/e_expf.c
  ./math/../sysdeps/ieee754/flt-32/e_logf.c
  ./math/../sysdeps/ieee754/flt-32/math_config.h
  ./math/../sysdeps/ieee754/flt-32/s_cosf.c
  ./math/../sysdeps/ieee754/flt-32/s_sincosf.h
  ./math/../sysdeps/ieee754/flt-32/s_sinf.c
  ./math/../sysdeps/x86/fpu/sincosf_poly.h
  ./math/./s_fdim_template.c
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                   D1mr             DLmr         Dw                   D1mw             DLmw           
--------------------------------------------------------------------------------
4,086,336,300 (74.63%) 512 ( 8.94%) 135 ( 3.76%) 906,855,277 (72.25%) 776,375 (87.19%) 475 ( 5.27%) 381,873,811 (92.82%) 485,357 (54.13%) 1,342 ( 1.32%)  events annotated

